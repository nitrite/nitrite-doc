window.__DOCS_SEARCH__ = [[{"i":"#","p":["Nitrite is a serverless, embedded, and self-contained NoSQL database. It is an open-source project that provides a simple API for persistent data storage. Nitrite database is designed to be lightweight, fast, and easy to use."]},{"l":"Welcome to Nitrite Database","p":["NO sql O bject ( NO2 a.k.a Nitrite) is a serverless, embedded, and self-contained NoSQL database. It is an open-source project that provides a simple API for persistent data storage. Nitrite database is designed to be lightweight, fast, and easy to use. Currently, it is available in Java, Kotlin, and Flutter.","Nitrite database can be used in various scenarios where a lightweight, embedded, and serverless NoSQL database is required. Some of the use cases for Nitrite database are:","Mobile and desktop applications","IoT devices and sensors","Web applications and APIs","Prototyping and testing","Data caching and synchronization","Data analysis and reporting","Nitrite database is designed to be simple and easy to use, making it a good choice for small to medium-sized projects that require a fast and reliable data storage solution."]},{"i":"features","l":"✨ Features","p":["Embedded, serverless","Simple API","Document-oriented","Schemaless document collection and object repository","Extensible storage engines","Indexing and full-text search","Simple query api","In-memory and file-based store","Transaction support","Schema migration support","Encryption support"]},{"i":"what-nitrite-is-not","l":"⛔ What Nitrite is not","p":["Nitrite is not an RDBMS. It is also not a distributed NoSQL database like MongoDB or Cassandra. It does not have any server for external application to connect to."]},{"i":"getting-started","l":"\uD83D\uDE80 Getting Started","p":["Nitrite database is currently available in Java, Kotlin, and Flutter. Please visit respective language page for getting started guide.","Java","Kotlin","Flutter"]},{"i":"license","l":"\uD83D\uDCDD License","p":["Nitrite database is an open-source project released under the terms of the Apache License, Version 2.0."]},{"i":"support","l":"\uD83E\uDD1D Support","p":["Give a ⭐️ if this project helped you! Please consider donating to support the development and maintenance."]},{"i":"contributing","l":"\uD83D\uDC9A Contributing","p":["Contributions, issues and feature requests are welcome! Feel free to open a discussion thread here."]},{"i":"showcase","l":"\uD83C\uDF9E️ Showcase","p":["If you are using Nitrite database in your project, please let us know. We will be happy to showcase your project here."]}],[{"i":"#","p":["This guide will help you get started with Nitrite database. It will show you how to create a database, create a collection, insert documents, and query documents in Java."]},{"l":"Getting Started in Java","p":["To get started with Nitrite database, you need to add the Nitrite BOM to your project. The BOM will help you to manage the dependencies. Details of the BOM can be found here.","To add the BOM to your project, follow the steps below:"]},{"l":"Add dependency","p":["Add Nitrite dependency to your project:"]},{"l":"Maven","p":["Add the nitrite dependency to your pom.xml file:"]},{"l":"Gradle","p":["Add the nitrite dependency to your build.gradle file:","The latest released version of Nitrite can be found here."]},{"l":"Snapshot builds","p":["Snapshot builds are available from Sonatype.","To use snapshot builds, you need to add the following repository to your pom.xml file:","Or, if you are using Gradle, add the following repository to your build.gradle file:"]},{"i":"upgrade-from-3x","l":"Upgrade from 3.x","p":["If you are upgrading from 3.x, please note that there are lots of breaking changes in the API. The whole library is re-written from scratch. It is recommended to go through this guide before upgrading.","You need to use the MVStore as your storage module to upgrade from 3.x. The RocksDB module is not backward compatible.","Nitrite will try to migrate your existing database to the latest version on the provided you are using the MVStore module. If you are using the RocksDB module, you need to migrate your database manually. However, it is recommended to take a backup of your database before upgrading."]}],[{"l":"Nitrite Database","p":["Nitrite database is a serverless, embedded, and self-contained Java NoSQL database. It is an open-source project that provides a simple API for persistent data storage. Nitrite database is designed to be lightweight, fast, and easy to use."]},{"l":"Creating a Database","p":["Nitrite database can be created in-memory or on-disk. By default, Nitrite database is created in-memory. To create a database on-disk, you need to add a storage module dependency to your project. More details about storage modules can be found here.","To create a database, you need to use NitriteBuilder class. To get an instance of NitriteBuilder, you need to call builder() method on Nitrite class."]},{"l":"In-memory Database","p":["If you don't load any on-disk storage module, then Nitrite will create an in-memory database. The below code snippet shows how to create a database in-memory."]},{"l":"On-disk Database","p":["The below code snippet shows how to create a database on-disk."]},{"l":"MVStore Backed Database","p":["More details about MVStore configuration can be found here."]},{"l":"RocksDB Backed Database","p":["More details about RocksDB configuration can be found here."]},{"l":"NitriteBuilder","p":["NitriteBuilder provides a fluent API to configure and create a Nitrite database instance."]},{"l":"Open or Create a Database","p":["To open or create a database, you need to call openOrCreate() method on NitriteBuilder instance. This method returns a Nitrite instance.","If no StoreModule is configured, then Nitrite will create an in-memory database. If a StoreModule is configured, then Nitrite will create a file-based database. If the database file does not exist, then Nitrite will create a new database file. If the database file already exists, then Nitrite will open the existing database file."]},{"l":"Securing a Database","p":["To secure a database, you need to call openOrCreate() method with username and password on NitriteBuilder instance. This method returns a Nitrite instance with the given username and password.","If you are using a file-based database, then you need to use the same username and password to open the database again. Otherwise, you will get a NitriteSecurityException.","Both username and password must be provided or both must be null."]},{"l":"Registering an EntityConverter","p":["Nitrite database uses a mapper to map Java entities to Nitrite documents and vice-versa. By default, Nitrite uses SimpleNitriteMapper as its mapper. This mapper uses EntityConverter s to map Java entities to Nitrite documents and vice-versa. To register an EntityConverter, you need to call registerEntityConverter() method on NitriteBuilder instance. This method returns the same NitriteBuilder instance.","More on EntityConverter can be found here."]},{"l":"Loading a Module","p":["Nitrite database is modular in nature. It provides various modules to extend its functionality. To load a module, you need to call loadModule() method on NitriteBuilder instance. This method returns the same NitriteBuilder instance."]},{"l":"Loading a Storage Module"},{"l":"Loading a Jackson Based Mapper Module","p":["More on the Nitrite's module system can be found here."]},{"l":"Adding Migration Steps","p":["Nitrite database supports schema migration. To configure a migration step, you need to call addMigrations() method on NitriteBuilder instance. This method returns the same NitriteBuilder instance.","More on the schema migration can be found here."]},{"l":"Current Schema Version","p":["To configure the current schema version, you need to call schemaVersion() method on NitriteBuilder instance. This method returns the same NitriteBuilder instance.","By default, the initial schema version is set to 1."]},{"l":"Field Separator Character","p":["To configure the field separator character, you need to call fieldSeparator() method on NitriteBuilder instance. This method returns the same NitriteBuilder instance.","It is used to separate field names in a nested document. For example, if a document has a field address which is a nested document, then the field street of the nested document can be accessed using address.street syntax.","The default field separator character is set to .."]}],[{"l":"Document","p":["Document is the basic unit of data in Nitrite database. It is a JSON like field-value pairs. The field is always a String and value can be anything including null. Document is schema-less, which means you can store any kind of data in a document.","Nitrite document supports nested document. That means, a value of a field can be another document. This allows you to create complex data structure."]},{"l":"Document Structure","p":["Nitrite document has the following structure."]},{"l":"Document Field","p":["Document field is always a String. It can be any valid string. The field cannot be null or empty string.","Below fields are reserved and cannot be used as key in a document.","_id: The unique identifier of a document. This field is auto-generated by Nitrite database during insertion.","_revision: The revision number of a document. This field is auto-generated by Nitrite database during insertion and update.","_source: The source collection name of a document.","_modified: The last modified timestamp of a document. This field is auto-generated by Nitrite database during insertion and update."]},{"l":"Document Value","p":["Document value can be any valid Java object. It can be null or any primitive type. It can also be a collection or an array. It can also be a nested document."]},{"l":"Document Identifier","p":["It is a unique identifier of a document. It is auto-generated by Nitrite database during insertion. It is a NitriteId and is stored as a String in the document."]},{"l":"NitriteId","p":["NitriteId is a unique identifier across the Nitrite database. Each document in a nitrite collection is associated with a NitriteId.","During insertion if a unique String value representing a 64-bit integer is supplied in the _id field of the document, then the value of the _id field will be used to generate the NitriteId. Otherwise, a new NitriteId will be generated and will be used in the _id field of the document.","The value of the NitriteId is a String representation of a 64-bit integer. The id generation is based on Twitter Snowflake algorithm. The id is composed of:","41 bits for time in milliseconds","10 bits for a machine id","12 bits for a sequence number","1 unused sign bit","The id is not guaranteed to be monotonically increasing. The id is sortable and the timestamp is stored in the id itself."]},{"l":"Retrieving a NitriteId from a Document","p":["The id can be retrieved from a document using Document.getId() method. If the document does not have an id, then it will create a new NitriteId and will set it in the document and will return the id. If the document already has an id, then it will return the id."]},{"l":"Field Separator","p":["To access a field of a nested document, or an element of an array field, you need to use the field separator.","Field separator is configurable. You can change the field separator character by calling NitriteBuilder.fieldSeparator() method.","Nitrite uses . as field separator by default."]},{"l":"Nested Document","p":["To specify or access a field of a nested document, you need to use the field separator character. That means, if a document has a field address which is a nested document, then the field street of the nested document can be accessed using address.street syntax."]},{"l":"Array Field","p":["To specify or access an element of an array field, you need to use the index of the element. For example, if a document has a field phone which is an array, then the first element of the array can be accessed using phone.0 syntax."]},{"l":"Creating a Document","p":["To create a document, you need to use Document.createDocument() method."]},{"l":"Creating an Empty Document"},{"l":"Creating a Document with Initial Field-value Pair"},{"l":"Creating a Document with a Map"},{"l":"Updating a Document","p":["To update a document, you need to use Document.put() method. This method takes two parameters, the field name and the value. If the field already exists in the document, then the value will be updated. If the field does not exist, then it will be created."]},{"l":"Retrieving a Value from Document","p":["To retrieve a value from document, you need to use Document.get() method. This method takes one parameter, the field name. If the field exists in the document, then the value will be returned. If the field does not exist, then it will return null.","To retrieve a value from a nested document, use the field separator character.","To retrieve an element from an array field, use the index of the element."]},{"l":"Removing a field from document","p":["To remove a field from document, you need to use Document.remove() method. This method takes one parameter, the field name. If the field exists in the document, then it will be removed. If the field does not exist, then it will do nothing.","To remove a field from a nested document, use the field separator character.","To remove an element from an array field, use the index of the element."]},{"l":"Checking If a Field Exists in Document","p":["To check if a field exists in a document, you need to use Document.containsField() method. This method takes one parameter, the field name. If the field exists in the document, then it will return true. If the field does not exist, then it will return false.","To check if a field exists in a nested document, use the field separator character.","It cannot check if an element exists in an array field."]}],[{"l":"Introduction","p":["NitriteCollection represents a named document collection stored in a Nitrite database. It persists documents in a Nitrite database. It is similar to a table in relational database or a collection in MongoDB.","Each document in a collection is associated with a unique NitriteId. It exposes a set of methods to perform CRUD operations on documents. It also supports indexing and querying. It also supports event based notification on document changes.","NitriteCollection is thread-safe and supports concurrent read and write operations."]},{"l":"Creating a Collection","p":["A NitriteCollection can be created using Nitrite class. You need to call getCollection() method on Nitrite class to get an instance of a NitriteCollection.","If the collection does not exist, then it will be created automatically. If a collection with the same name already exists, then it will return the existing collection."]},{"l":"Limitations on Collection Name","p":["A collection name cannot be null or empty string. It cannot contains any of the following characters:","|(pipe)",":(colon)","+(plus)","The name also cannot be any of the following reserved words:","$nitrite_users","$nitrite_index_meta","$nitrite_index","$nitrite_meta_map","$nitrite_store_info","$nitrite_catalog"]}],[{"l":"Write Operations"},{"l":"Inserting Documents","p":["Documents can be inserted into a collection using insert() method. It takes one or multiple Document objects as input parameter. It returns a WriteResult object.","If the document has a NitriteId already in it's _id field, then it will be used as a unique key to identify the document in the collection. Otherwise, a new NitriteId will be generated and inserted into the document.","If any of the field is already indexed in the collection, then the index will be updated accordingly.","This operation will notify all the registered CollectionEventListener with EventType.Insert event."]},{"l":"Inserting a Single Document"},{"l":"Inserting Multiple Documents"},{"l":"Error Scenarios","p":["If the document is null, then it will throw a ValidationException.","If the document contains invalid value in it's _id field, then it will throw a InvalidIdException.","If there is another document with the same _id value in the collection, then it will throw a UniqueConstraintException.","If a field of the document is unique indexed and it's value violates the index constraint, then it will throw a UniqueConstraintException."]},{"l":"WriteResult","p":["WriteResult contains the result of a write operation. It contains the following information:","Number of documents affected by the write operation. You can get this value using getAffectedCount() method.","List of NitriteId of the documents affected by the write operation. The WriteResults implements IterableNitriteId interface. So you can iterate over the WriteResult to get the NitriteId of the documents affected by the write operation."]},{"l":"Updating Documents","p":["Documents can be updated in a collection using update() method. There are several overloaded version of update() method. You can update a single document or multiple documents at a time. You can also update a document using a filter.","This operation will notify all the registered CollectionEventListener with EventType.Update event."]},{"l":"Updating a Single Document","p":["You can update a single document using update() method. It takes a Document object as input parameter. It returns a WriteResult object. The document must contain a valid NitriteId in it's _id field. The document must not be null.","If the document does not contain a valid NitriteId in it's _id field, then it will throw a NotIdentifiableException."]},{"l":"Upserting a Single Document","p":["You can upsert a single document using update() method. It takes a Document object as the first input parameter. It takes a boolean value as the second input parameter. If the second input parameter is true, then it will insert the document if it does not exist in the collection. Otherwise, it will update the document if it exists in the collection. It returns a WriteResult object. The document must not be null."]},{"l":"Updating Using a Filter","p":["You can update a document using a filter. It takes a Filter object as the first input parameter. It takes a Document object as the second input parameter. It returns a WriteResult object. The document must not be null or empty.","If the filter result matches multiple documents, then all the documents will be updated."]},{"l":"Updating Using a Filter and Options","p":["You can update a document using a filter and options. It takes a Filter object as the first input parameter. It takes a Document object as the second input parameter. It takes a UpdateOptions object as the third input parameter. It returns a WriteResult object. The document must not be null or empty."]},{"l":"UpdateOptions","p":["UpdateOptions is a class that contains several options for update operation. It has the following options:","insertIfAbsent: If this option is true, then it will insert the document if it does not exist in the collection. Otherwise, it will update the document if it exists in the collection.","justOnce: If this option is true, then it will update only the first document matched by the filter. Otherwise, it will update all the documents matched by the filter."]},{"l":"Removing Documents","p":["Documents can be removed from a collection using remove() method. There are several overloaded version of remove() method. You can remove a single document or multiple documents at a time using a filter.","This operation will notify all the registered CollectionEventListener with EventType.Remove event."]},{"l":"Removing a Single Document","p":["You can remove a single document using remove() method. It takes a Document object as input parameter. It returns a WriteResult object. The document must contain a valid NitriteId in it's _id field. The document must not be null.","If the document does not contain a valid NitriteId in it's _id field, then it will throw a NotIdentifiableException."]},{"l":"Removing Using a Filter","p":["You can remove a document using a filter. It takes a Filter object as the input parameter. It returns a WriteResult object.","If the filter result matches multiple documents, then all the documents will be removed."]},{"l":"Removing Using a Filter and Options","p":["You can remove a document using a filter and options. It takes a Filter object as the first input parameter. It takes a boolean value as the second input parameter. If the second input parameter is true, then it will remove only the first document matched by the filter. Otherwise, it will remove all the documents matched by the filter. It returns a WriteResult object."]}],[{"l":"Read Operations"},{"l":"Find Operations","p":["You can search documents in a collection using find() method. There are several overloaded version of find() method using a filter or find options or both. You can also search a document using it's NitriteId."]},{"l":"Filters","p":["Nitrite uses filters to find documents in a collection. A filter is a simple expression which evaluates to true or false. More information about filters can be found here."]},{"l":"Find All Documents","p":["You can find all documents in a collection by calling find(). It returns a DocumentCursor object."]},{"l":"Finding a Document Using NitriteId","p":["You can find a document using it's NitriteId by calling getById(). It takes a NitriteId as input parameter. It returns a Document object if the document is found. Otherwise, it returns null."]},{"l":"Finding a Document Using a Filter","p":["You can find a document using a filter. It takes a Filter object as input parameter. It returns a DocumentCursor object.","If there is an index on the field specified in the filter, this operation will use the index to find the document. Otherwise, it will scan the entire collection to find the document."]},{"l":"Finding a Document Using a Filter and Options","p":["You can find a document using a filter and options. It takes a Filter object as the first input parameter. It takes a FindOptions object as the second input parameter. It returns a DocumentCursor object."]},{"l":"FindOptions","p":["FindOptions is a class that contains several options for find operation. It has the following options:","limit: It specifies the maximum number of documents to be returned by the find operation.","skip: It specifies the number of documents to be skipped from the beginning of the result set.","orderBy: It specifies a collection of fields to be sorted by, along with sort order for each field. The sort order can be SortOrder.Ascending or SortOrder.Descending.","collator: It specifies a collator to be used for sorting. If this option is not specified, then the default collator will be used.","distinct: It specifies if the find operation should return distinct documents. If this option is true, then it will return only the distinct documents. Otherwise, it will return all the documents matched by the filter."]},{"l":"DocumentCursor","p":["DocumentCursor represents a result set of a find operation. It provides methods to iterate over the result of a find operation and retrieve the documents. It also provides methods like projection, join etc. to get the desired result."]},{"l":"Iterating over Documents","p":["The DocumentCursor extends Iterable interface. So, you can iterate over the documents using for-each loop.","A DocumentCursor is a lazy iterable. It does not load all the documents in memory at once. It loads the documents in memory as needed. So, it is memory efficient."]},{"l":"Getting the Documents","p":["You can get the documents at once using toList() and toSet() methods. It returns a List and Set of documents respectively."]},{"l":"Getting the First Document","p":["You can get the first document using firstOrNull() method. It returns the first document if the cursor has any document. Otherwise, it returns null."]},{"l":"Getting the Size of the Result Set","p":["You can get the size of the result set using size() method. It returns the number of documents in the result set."]},{"l":"Projection","p":["You can project the result set using project() method. It takes a Document as the only input parameter. It returns a DocumentCursor object.","The document must contain only the fields that needs to be projected. The field values must be null or a nested document. The condition holds true for nested documents as well.","Let's say you have a document like this:","And you want to project only lastName and address.street fields. Then you can do it like this:","The result set will contain only lastName and address.street fields."]},{"l":"Join","p":["You can join two cursors using join() method. It takes a DocumentCursor as the first input parameter. It takes a Lookup as the second input parameter. It returns a RecordStream object.","The join operation is similar to SQL left outer join operation. It takes two cursors and a lookup object. The lookup object contains the join condition.","Let's say you have two collections users and orders. The users collection contains the following documents:","And the orders collection contains the following documents:","Now, you want to join these two collections using userId field. Then you can do it like this:","The result set will contain the following documents:"]},{"l":"FindPlan","p":["FindPlan is a class that contains the execution plan of a find operation. It has the following properties:","byIdFilter: It contains the filter for finding a document using NitriteId.","indexScanFilter: It contains the filter for finding a document using index.","collectionScanFilter: It contains the filter for finding a document using full scan.","indexDescriptor: It contains the index descriptor for finding a document using index.","indexScanOrder: It contains the sort order for finding a document using index.","blockingSortOrder: It contains the sort order for finding a document using full scan.","skip: It contains the number of documents to be skipped from the beginning of the result set.","limit: It contains the maximum number of documents to be returned by the find operation.","distinct: It specifies if the find operation returns distinct documents.","collator: It specifies a collator to be used for sorting.","subPlans: It contains the sub plans for finding a document using or filter.","You can get the execution plan of a find operation using getFindPlan() method. It returns a FindPlan object."]}],[{"l":"Indexing","p":["Indexing is a way to optimize the performance of a database by minimizing the number of disk accesses required when a query is processed. It is a data structure technique which is used to quickly locate and access the data in a database.","Nitrite supports indexing on a collection. It supports indexing on a single field or multiple fields. It also supports full-text indexing."]},{"l":"Index Types","p":["Nitrite supports the following types of index out of the box:","Unique Index","Non-Unique Index","Full-text Index"]},{"l":"Unique Index","p":["A unique index ensures that the indexed field contains unique value. It does not allow duplicate value in the indexed field. It also ensures that the indexed field is not null."]},{"l":"Non-unique Index","p":["A non-unique index does not ensure that the indexed field contains unique value. It allows duplicate value in the indexed field."]},{"l":"Full-text Index","p":["A full-text index is used to search text content in a document. It is useful when you want to search text content in a document. It is also useful when you want to search text content in a document in a language other than English.","Document's _id field is always indexed.","Indexing on non-comparable value is not supported."]},{"l":"Custom Index","p":["You can also create your own custom index. You need to implement NitriteIndexer interface to create your own custom index. NitriteIndexer is a NitritePlugin, so you need to register it using loadModule() method while opening a database. During index creation you need to pass the type of the custom index in IndexOptions object.","One of such custom index implementation can be found in spatial module. It provides spatial indexing on a collection. More on spatial indexing can be found here."]},{"l":"Creating an Index","p":["You can create an index on a collection using createIndex() method. There are several overloaded version of createIndex() method. You can create an index on a single field or multiple fields."]},{"l":"Creating a Unique Index","p":["You can create a unique index on a single field or multiple fields. It takes the name of the fields on which the index will be created as input parameter."]},{"l":"Creating a Non-unique Index","p":["You can create a non-unique index on a single field or multiple fields by passing the index type as IndexType.NON_UNIQUE in IndexOptions object and the name of the fields on which the index will be created as input parameters."]},{"l":"Creating a Full-text Index","p":["You can create a full-text index on a single field by passing the index type as IndexType.FULL_TEXT in IndexOptions object and the name of the field on which the index will be created as input parameters.","Full-text index is not supported on multiple fields."]},{"l":"Creating Index on Array Field","p":["Nitrite supports creating index on array field. It will create index on each element of the array. For example, if you have a document like this:","You can create index on phones field like this:"]},{"l":"Creating Index on Nested Field","p":["You can create index on nested field. For example, if you have a document like this:","You can create a unique index on street field like this:","You cannot create index on nested field if the parent field is an array."]},{"l":"Rebuilding an Index","p":["You can rebuild an index on a collection using rebuildIndex() method. It takes the name of the fields on which the index will be rebuilt as input parameter."]},{"l":"Dropping an Index","p":["You can drop an index on a collection using dropIndex() method. It takes the name of the fields on which the index will be dropped as input parameter."]},{"l":"Dropping All Indexes","p":["You can drop all indexes on a collection using dropAllIndices() method."]},{"l":"Getting All Indexes","p":["You can get all indexes on a collection using listIndices() method. It returns a Collection of IndexDescriptor object."]},{"l":"IndexDescriptor","p":["IndexDescriptor is a simple class which contains the following information about an index:","collectionName: The name of the collection on which the index is created.","indexType: The type of the index.","fields: A Fields object containing the name of the fields on which the index is created."]},{"l":"Checking If an Index Exists","p":["You can check if an index exists on a collection using hasIndex() method. It takes the name of the fields on which the index will be checked as input parameter."]},{"l":"Error Scenarios","p":["The following error scenarios are possible while creating an index:","If another index of any type is already created on the collection on the same field(s), then it will throw IndexingException.","If a unique index is created on a field and the field contains duplicate value, then it will throw UniqueConstraintException.","If a full-text index is created on multiple fields, then it will throw IndexingException.","If a full-text index is created on a field which is not a String, then it will throw IndexingException.","If you try to drop an index which does not exist, then it will throw IndexingException.","If you try to rebuild an index which does not exist, then it will throw IndexingException."]}],[{"l":"Other Operations"},{"l":"Size of a Collection","p":["You can get the size of a collection using size() method. It returns the number of documents in the collection."]},{"l":"Clearing a Collection","p":["You can clear all the documents from a collection using clear() method. It removes all the documents from the collection and index entries from the indexes. It does not drop the collection."]},{"l":"Dropping a Collection","p":["You can drop a collection using drop() method. It removes all the documents from the collection and index entries from the indexes. It also drops all the indexes associated with the collection. It also removes the collection from the database.","You can call isDropped() method to check if the collection is dropped or not.","Any further operation on a dropped collection will throw NitriteIOException."]},{"l":"Closing a Collection","p":["You can close a collection using close() method. Any further operation on a closed collection will throw NitriteIOException.","After closing a collection, you must re-open it via Nitrite.getCollection() method to perform any operation on it.","You can call isOpen() method to check if the collection is closed or not."]},{"l":"Event Listener","p":["You can register an event listener on a collection to get notified on document changes. The event listener must implement CollectionEventListener interface. It will receive CollectionEventInfo whenever a document is inserted, updated or removed from the collection.","You can also remove an event listener from a collection."]},{"l":"CollectionEventInfo","p":["CollectionEventInfo contains the following information:","item- the document which is inserted, updated or removed.","originator- the name of the collection on which the event is fired.","eventType- the type of the event. It can be any of the following:","EventType.Insert","EventType.Update","EventType.Remove","EventType.IndexStart","EventType.IndexEnd","timestamp- the timestamp of the event."]},{"l":"Attributes","p":["Attributes is a metadata information associated with a collection.","You can get/set attributes on a collection. The attributes are stored in the database and can be retrieved later. The attributes are stored in a special map named $nitrite_meta_map."]},{"l":"Processors","p":["Processors are used to process documents before writing them into or after reading them from a collection.","Processors are useful when you want to add some additional information in a document or transform any field before inserting or updating it in a collection. Processors are also useful when you want to validate a document before inserting or updating it in a collection.","Processors are registered on a collection. A collection can have multiple processors. Processors are executed in the order they are registered."]},{"l":"Registering a Processor","p":["You can register a processor on a collection using addProcessor() method. It takes a Processor as input parameter."]},{"l":"Available Processors","p":["Nitrite provides a StringFieldEncryptionProcessor which can be used to encrypt a field before writing it into a collection and decrypt a field after reading it from a collection.","More on this is described in Support."]}],[{"l":"Introduction","p":["ObjectRepository provides a simple and type-safe API for storing and retrieving Java objects in a Nitrite database. It is built on top of NitriteCollection and provides a similar API for CRUD operations. It also supports indexing and querying. It also supports event based notification on object changes.","ObjectRepository is thread-safe and supports concurrent read and write operations."]},{"l":"Creating a Repository","p":["A ObjectRepository can be created using Nitrite class. You need to call getRepository() method on Nitrite class to get an instance of a ObjectRepository. If the repository does not exist, then it will be created automatically. If a repository with the same name already exists, then it will return the existing repository.","There are several overloaded methods available to create a repository. You can pass a class type or an EntityDecorator along with an optional string key to create a repository."]},{"l":"Creating a Repository with Class Type","p":["You can create a ObjectRepository by passing a class type to getRepository() method."]},{"l":"Creating a Repository with Class Type and Key","p":["You can create a keyed ObjectRepository by passing a class type and a key to getRepository() method.","One typical use case of this keyed repository is to create a repository for each user in a multi-user application. The key can be the user name or user id. This will ensure that each user will have a separate repository for storing objects."]},{"l":"Creating a Repository with EntityDecorator","p":["A ObjectRepository can be created using EntityDecorator. This is useful when you cannot modify the object class to add annotations.","More details about EntityDecorator can be found here."]},{"l":"Creating a Repository with EntityDecorator and Key","p":["A keyed ObjectRepository can be created using EntityDecorator and a key. This is useful when you cannot modify the object class to add annotations.","More details about EntityDecorator can be found here."]}],[{"l":"Entity","p":["An entity is a Java object that can be stored in a Nitrite database. An entity can be a simple POJO or a complex object with nested objects. Every entity in an ObjectRepository is actually converted to a Document before storing in the underlying NitriteCollection. When an entity is converted to a Document, the fields of the entity are mapped to the fields of the Document. While retrieving an entity from the ObjectRepository, the Document is converted back to the entity.","Nitrite uses a NitriteMapper implementation to convert an entity to a Document and vice versa. By default, Nitrite uses an EntityConverter based implementation of NitriteMapper to convert an entity to a Document. You can also provide your own implementation of NitriteMapper to convert an entity to a Document.","More on NitriteMapper can be found here."]},{"l":"Annotations","p":["Nitrite uses annotations to map an entity to a Document. There are several annotations available to map an entity to a Document. These annotations are:","Entity","Id","Index","Indices","InheritIndices","In case you cannot modify the entity class to add annotations, you can use EntityDecorator to add metadata to an entity. More on EntityDecorator can be found here."]},{"l":"Entity Annotation","p":["Entity annotation is used to mark a class as an entity. It is a class level annotation and takes optional value and indices parameters.","The value parameter is used to specify the name of the NitriteCollection in which the entity will be stored as a Document. If the value parameter is not specified, then the name of the collection will be the name of the class. The indices parameter is used to specify the indices on the repository."]},{"l":"Id Annotation","p":["Id annotation is used to mark a field as the unique identifier of the entity. It is a field level annotation and takes optional fieldName parameter. The fieldName parameter is used to specify the name of the field in the document. If the fieldName parameter is not specified, then the name of the field in the class will be used as the name of the field in the document."]},{"l":"Embedded Id","p":["Nitrite also supports embedded id. In case of embedded id, the field should be marked with Id annotation and the fieldName and embeddedFields parameters should be specified. The fieldName parameter is used to specify the name of the field in the document. The embeddedFields parameter is used to specify the name of the fields in the embedded object.","The above Id annotation will create a unique compound index on the fields - emp_Id.uniqueId and emp_Id.companyId."]},{"l":"Data Type","p":["The data type of the field marked with Id annotation can be either Comparable or NitriteId. If the data type is Comparable, then the value of the field should be unique. If the data type is NitriteId, then the value of the field will be generated by Nitrite. But in the case of embedded id, the data type of the embedded fields can only be Comparable, it can't be NitriteId."]},{"l":"Index Annotation","p":["Index annotation is used to declare an index on an entity field. It is a class level annotation and takes mandatory fields parameter and optional type parameter. The fields parameter is used to specify the name of the fields in the document to be indexed. The type parameter is used to specify the type of the index. If the type parameter is not specified, then the type of the index will be IndexType.UNIQUE."]},{"l":"Indices Annotation","p":["Indices annotation is used declare multiple indices on an entity. It is a class level annotation and takes mandatory value parameter. The value parameter is used to specify the list of Index annotations."]},{"l":"InheritIndices Annotation","p":["InheritIndices annotation is used to inherit the indices from the parent class. It is a class level annotation and takes no parameter.","If the InheritIndices annotation is not specified, then the indices will not be inherited from the parent class."]},{"l":"EntityDecorator","p":["EntityDecorator is used to add metadata to an entity. If you cannot modify the entity class to add annotations, then you can use EntityDecorator to add metadata to an entity. You can use EntityDecorator to add id, indices and collection name for an entity.","While creating or opening a repository, you can pass an instance of EntityDecorator to the getRepository() method on Nitrite class. Nitrite will extract the metadata from the EntityDecorator instance and use it to create the repository.","To write an EntityDecorator for an entity, you need to implement the EntityDecorator interface. Let's take an example of a Product entity.","The Product entity has an embedded id ProductId and two indices on a nested object Manufacturer. To write an EntityDecorator for the Product entity, you need to implement the EntityDecorator interface as follows.","which is equivalent to the following entity class."]},{"l":"EntityId","p":["EntityId is used to specify the id field of an entity. It takes mandatory fieldName parameter and optional embeddedFields parameter in case of embedded id. The fieldName parameter is used to specify the name of the field in the document. The embeddedFields parameter is used to specify the name of the fields in the embedded object.","Here productId is the name of the field in the document and uniqueId and productCode are the names of the fields in the embedded object. This will create a unique compound index on the fields - productId.uniqueId and productId.productCode."]},{"l":"EntityIndex","p":["EntityIndex is used to specify the indices on an entity. It takes mandatory type parameter and fields parameter. The type parameter is used to specify the type of the index. The fields parameter is used to specify the name of the fields in the document to be indexed.","Here manufacturer.name is the name of the field in the document and productName and manufacturer.uniqueId are the names of the fields in the document. This will create a non-unique index on the field manufacturer.name and a unique compound index on the fields - productName and manufacturer.uniqueId."]},{"l":"EntityName","p":["EntityName is used to specify the name of the collection in which the entity will be stored. It takes no parameter.","Here product is the name of the NitriteCollection in which the product document will be stored."]}],[{"l":"NitriteMapper","p":["NitriteMapper is a simple and lightweight object mapper which can be used to map Java objects to Nitrite documents and vice-versa. Nitrite uses a NitriteMapper implementation to map Java entities to Nitrite documents and vice-versa while storing and retrieving objects from an ObjectRepository."]},{"l":"SimpleNitriteMapper","p":["Nitrite provides a default NitriteMapper implementation called SimpleNitriteMapper. This is a simple and lightweight mapper which uses EntityConverter to map a Java entity to Nitrite documents and vice-versa. This mapper is suitable for most of the use cases."]},{"l":"EntityConverter","p":["EntityConverter is a simple interface which provides methods to convert a Java entity to Nitrite document and vice-versa. For each entity, you need to provide an implementation of EntityConverter and register it with SimpleNitriteMapper. SimpleNitriteMapper will use this converter to map the entity to Nitrite document and vice-versa.","Let's take an example of Product class.","To map this entity to Nitrite document, we need to provide an implementation of EntityConverter for each entity. Let's take a look at the converter for Product class.","Similarly, we need to provide converter for ProductId and Manufacturer class.","Once the converters are ready, we need to register them with registerEntityConverter() method on NitriteBuilder instance.","we can also register the converters with SimpleNitriteMapper instance and then pass the instance to loadModule() method.","NitriteMapper is a NitritePlugin. So, you need to load it using loadModule() method on NitriteBuilder. More on Nitrite's module system can be found here.","If you have used the registerEntityConverter() method on NitriteBuilder instance, Nitrite will only use SimpleNitriteMapper to map the entities. It will ignore any other NitriteMapper implementation you have provided using loadModule() method."]},{"l":"JacksonMapper","p":["Nitrite also provides a Jackson based mapper called JacksonMapper. This mapper uses Jackson's ObjectMapper to map Java entities to Nitrite documents and vice-versa. Here you don't need to provide any EntityConverter. Jackson will use its own ObjectMapper to map the entities.","More on this mapper can be found here."]},{"l":"Custom NitriteMapper","p":["Apart from SimpleNitriteMapper and JacksonMapper, you can also provide your own implementation of NitriteMapper. You need to implement NitriteMapper interface and provide your own implementation. Once the implementation is ready, you need to load it using loadModule() method on NitriteBuilder while building the database."]}],[{"l":"Write Operations"},{"l":"Inserting Entities","p":["Entities can be inserted into a repository using insert() method. It takes one or multiple Java entities as input parameter. It returns a WriteResult object.","If the entity has a NitriteId field, then the field value would be populated with a new NitriteId before inserting into the repository.","If any of the field is already indexed in the repository, then the index will be updated accordingly.","This operation will notify all the registered CollectionEventListener with EventType.Insert event."]},{"l":"Inserting a Single Entity"},{"l":"Inserting Multiple Entities"},{"l":"Error Scenarios","p":["If the entity is null, then it will throw a ValidationException.","If a field of the entity is unique indexed and it's value violates the index constraint, then it will throw a UniqueConstraintException."]},{"l":"WriteResult","p":["More information about WriteResult can be found here."]},{"l":"Updating Entities","p":["Entities can be updated in a repository using update() method. There are several overloaded methods available for updating entities. All of them returns a WriteResult object.","This operation will notify all the registered CollectionEventListener with EventType.Update event."]},{"l":"Updating a Single Entity","p":["You can update a single entity using update() method. It takes a Java entity as input parameter. It returns a WriteResult object.","The entity must have a valid id field marked with @Id annotation. In case an EntityDecorator is used, the getIdField() method must return a valid non-null EntityId object. Otherwise, it will throw a NotIdentifiableException."]},{"l":"Upserting a Single Entity","p":["You can upsert a single entity using update() method. It takes a Java entity as first input parameter. It takes a boolean value as second input parameter. If the second input parameter is true, then it will insert the entity if it does not exist in the repository. Otherwise, it will update the entity if it exists in the repository. It returns a WriteResult object."]},{"l":"Updating Using a Filter","p":["You can update an entity using a filter. It takes a Filter object as first input parameter. It takes a Java entity as second input parameter. It returns a WriteResult object. The entity must not be null.","If the filter result matches multiple entities, then all the entities will be updated."]},{"l":"Updating Using a Filter and Options","p":["You can update an entity using a filter and options. It takes a Filter object as first input parameter. It takes a Java entity as second input parameter. It takes a UpdateOptions object as third input parameter. It returns a WriteResult object. The entity must not be null."]},{"l":"UpdateOptions","p":["More information about UpdateOptions can be found here."]},{"l":"Updating Using a Filter and Document","p":["You can update multiple entities using a filter and document. It takes a Filter object as first input parameter. It takes a Document object as second input parameter. It returns a WriteResult object. The document must not be null or empty.","If the filter result matches multiple entities, then all the entities will be updated. The document must contain only the fields that needs to be updated.","The document should not contain _id field."]},{"i":"updating-using-a-filter-document-and-options","l":"Updating Using a Filter, Document and Options","p":["You can update multiple entities using a filter, document and options. It takes a Filter object as first input parameter. It takes a Document object as second input parameter. It takes a boolean value as third input parameter. If the third input parameter is true, then it will only update the first entity matched by the filter. Otherwise, it will update all the entities matched by the filter. It returns a WriteResult object. The document must not be null or empty.","The document must contain only the fields that needs to be updated.","The document should not contain _id field."]},{"l":"Removing Entities","p":["Entities can be removed from a repository using remove() method. There are several overloaded methods available for removing entities. All of them returns a WriteResult object.","This operation will notify all the registered CollectionEventListener with EventType.Remove event."]},{"l":"Removing a Single Entity","p":["You can remove a single entity using remove() method. It takes a Java entity as input parameter. It returns a WriteResult object.","The entity must have a valid id field marked with @Id annotation. In case an EntityDecorator is used, the getIdField() method must return a valid non-null EntityId object. Otherwise, it will throw a NotIdentifiableException."]},{"l":"Removing Using a Filter","p":["You can remove an entity using a filter. It takes a Filter object as input parameter. It returns a WriteResult object.","If the filter result matches multiple entities, then all the entities will be removed."]},{"l":"Removing Using a Filter and Options","p":["You can remove an entity using a filter and options. It takes a Filter object as first input parameter. It takes a boolean value as second input parameter. If the second input parameter is true, then it will remove only the first entity matched by the filter. Otherwise, it will remove all the entities matched by the filter. It returns a WriteResult object."]}],[{"l":"Read Operations"},{"l":"Find Operations","p":["You can search entities in a repository using find() method. There are several overloaded version of find() method using a filter or find options or both. You can also search an entity using it's id."]},{"l":"Filters","p":["Nitrite uses filters to find entities in a repository. A filter is a simple expression which evaluates to true or false. More information about filters can be found here."]},{"l":"Find All Entities","p":["You can find all entities in a repository by calling find(). It returns a Cursor object."]},{"l":"Finding an Entity Using Id","p":["You can find an entity using it's id by calling getById(). It takes an id as input parameter. It returns an entity if the entity is found. Otherwise, it returns null."]},{"l":"Finding an Entity Using a Filter","p":["You can find an entity using a filter. It takes a Filter object as input parameter. It returns a Cursor object.","If there is an index on the field specified in the filter, this operation will use the index to find the entity. Otherwise, it will scan the entire repository to find the entity."]},{"l":"Finding an Entity Using a Filter and Options","p":["You can find an entity using a filter and options. It takes a Filter object as the first input parameter. It takes a FindOptions object as the second input parameter. It returns a Cursor object."]},{"l":"FindOptions","p":["More information about FindOptions can be found here."]},{"l":"Cursor","p":["Cursor represents a result set of a find operation. It provides methods to iterate over the result of a find operation and retrieve the entities. It also provides methods like projection, join etc. to get the desired result."]},{"l":"Iterating over Entities","p":["The Cursor extends Iterable interface. So, you can iterate over the entities using for-each loop.","A Cursor is a lazy iterable. It will not load all the entities in memory at once. It will load the entities in memory as needed. So, it is memory efficient."]},{"l":"Getting the Entities","p":["You can get the entities from the cursor at once using toList() and toSet() method. It returns a List and Set of entities respectively."]},{"l":"Getting the First Entity","p":["You can get the first entity from the cursor using firstOrNull() method. It returns the first entity if the cursor is not empty. Otherwise, it returns null."]},{"l":"Getting the Size of the Cursor","p":["You can get the size of the cursor using size() method. It returns the number of entities in the cursor."]},{"l":"Projection","p":["You can project the cursor using project() method. It takes another entity as input parameter. It returns a Cursor object of the projected entity.","The projected entity must contain only the fields that needs to be projected.","Let's say you have an entity like this:","And you want to project only lastName and address.street fields. Then you can define a new entity like this:","And then you can project the cursor like this:"]},{"l":"Join","p":["You can join two cursors using join() method. It takes another cursor as the first input parameter. It takes a Lookup as the second input parameter and type of the join as the third input parameter. It returns a RecordStream object.","The join operation is similar to SQL left outer join operation. It takes two cursors and a lookup object. The lookup object contains the join condition.","Let's say you have two entities like this:","And you want to join these two entities using userId field. Then you can define a new entity like this:","And then you can join the cursors like this:"]},{"l":"FindPlan","p":["You can get the FindPlan of a cursor using getFindPlan() method. It returns a FindPlan object.","More information about FindPlan can be found here."]}],[{"l":"Indexing","p":["Indexing is a way to optimize the performance of a database by minimizing the number of disk accesses required when a query is processed. It is a data structure technique which is used to quickly locate and access the data in a database.","Nitrite supports indexing on a repository. It supports indexing on a single field or multiple fields. It also supports full-text indexing.","Indexes for an entity can be defined using various annotations like @Id, @Index, @Indices etc. More information about annotations can be found here. It can also be managed using various methods of ObjectRepository interface."]},{"l":"Index Types","p":["Nitrite supports the following types of index out of the box:","Unique Index","Non-Unique Index","Full-text Index"]},{"l":"Unique Index","p":["A unique index ensures that the indexed field contains unique value. It does not allow duplicate value in the indexed field. It also ensures that the indexed field is not null."]},{"l":"Non-unique Index","p":["A non-unique index does not ensure that the indexed field contains unique value. It allows duplicate value in the indexed field."]},{"l":"Full-text Index","p":["A full-text index is used to search text content in an entity. It is useful when you want to search text content in an entity. It is also useful when you want to search text content in an entity in a language other than English.","Indexing on non-comparable value is not supported."]},{"l":"Custom Index","p":["You can also create your own custom index. More information about custom index can be found here."]},{"l":"Creating an Index","p":["You can define indexes for an entity using annotations. You can also create indexes using ObjectRepository interface."]},{"l":"Creating a Unique Index","p":["You can create a unique index on a single field or multiple fields. It takes the name of the fields on which the index will be created as input parameter."]},{"l":"Using Annotations","p":["You can create a unique index on a single field or multiple fields using annotations. You can use @Id annotation to create a unique index on a single field. You can use @Index annotation to create a unique index on multiple fields."]},{"l":"Using ObjectRepository","p":["You can create a unique index on a single field or multiple fields using createIndex() method. It takes the name of the fields on which the index will be created as input parameter."]},{"l":"Creating a Non-unique Index","p":["You can create a non-unique index on a single field or multiple fields by passing the index type as IndexType.NON_UNIQUE."]},{"i":"using-annotations-1","l":"Using Annotations","p":["You can create a non-unique index on a single field or multiple fields using annotations. You can use @Index annotation to create a non-unique index on multiple fields."]},{"i":"using-objectrepository-1","l":"Using ObjectRepository","p":["You can create a non-unique index on a single field or multiple fields using createIndex() method. It takes the name of the fields on which the index will be created as input parameter and the index type as IndexType.NON_UNIQUE."]},{"l":"Creating a Full-text Index","p":["You can create a full-text index on a single field by passing the index type as IndexType.FULL_TEXT."]},{"i":"using-annotations-2","l":"Using Annotations","p":["You can create a full-text index on a single field using annotations. You can use @Index annotation to create a full-text index on a single field."]},{"i":"using-objectrepository-2","l":"Using ObjectRepository","p":["You can create a full-text index on a single field using createIndex() method. It takes the name of the fields on which the index will be created as input parameter and the index type as IndexType.FULL_TEXT.","Full-text index is not supported on multiple fields."]},{"l":"Creating Index on Array Field","p":["Nitrite supports creating index on array field. It will create index on each element of the array. For example, if you have an entity like this:","You can create index on tags field like this:"]},{"l":"Creating Index on Embedded Field","p":["Nitrite supports creating index on embedded field. For example, if you have entities like this:","You can create index on name of Manufacturer entity via annotation like this:","Or you can create index on name of Manufacturer entity via ObjectRepository like this:","You cannot create index on nested field if the parent field is an array."]},{"l":"Rebuilding an Index","p":["You can rebuild an index on a repository using rebuildIndex() method. It takes the name of the fields on which the index will be rebuilt as input parameter."]},{"l":"Dropping an Index","p":["You can drop an index on a repository using dropIndex() method. It takes the name of the fields on which the index will be dropped as input parameter."]},{"l":"Dropping All Indexes","p":["You can drop all indexes on a repository using dropAllIndices() method."]},{"l":"Getting All Indexes","p":["You can get all indexes on a repository using listIndices() method. It returns a Collection of IndexDescriptor object."]},{"l":"IndexDescriptor","p":["IndexDescriptor is a simple class which contains the following information about an index:","collectionName: The name of the collection on which the index is created.","indexType: The type of the index.","fields: A Fields object containing the name of the fields on which the index is created."]},{"l":"Checking If an Index Exists","p":["You can check if an index exists on a repository using hasIndex() method. It takes the name of the fields on which the index will be dropped as input parameter."]},{"l":"Error Scenarios","p":["The following error scenarios are possible while creating an index:","If another index of any type is already created on the repository on the same field(s), then it will throw IndexingException.","If a unique index is created on a field and the field contains duplicate value, then it will throw UniqueConstraintException.","If a full-text index is created on multiple fields, then it will throw IndexingException.","If a full-text index is created on a field which is not a String, then it will throw IndexingException.","If you try to drop an index which does not exist, then it will throw IndexingException.","If you try to rebuild an index which does not exist, then it will throw IndexingException."]}],[{"l":"Other Operations"},{"l":"Size of a Repository","p":["You can get the size of a repository using size() method. It returns the number of entities in the repository."]},{"l":"Clearing a Repository","p":["You can clear all the entities from a repository using clear() method. It removes all the entities from the repository and index entries from the indexes. It does not drop the repository."]},{"l":"Dropping a Repository","p":["You can drop a repository using drop() method. It removes all the entities from the repository and index entries from the indexes. It also drops all the indexes associated with the repository. It also removes the repository from the database.","You can call isDropped() method to check if the repository is dropped or not.","Any further operation on a dropped repository will throw NitriteIOException."]},{"l":"Closing a Repository","p":["You can close a repository using close() method. Any further operation on a closed repository will throw NitriteIOException.","After closing a repository, you must re-open it via Nitrite.getRepository() method to perform any operation on it.","You can call isOpen() method to check if the repository is closed or not."]},{"l":"Event Listener","p":["You can register an event listener on a repository to get notified on entity changes. The event listener must implement CollectionEventListener interface. It will receive CollectionEventInfo whenever an entity is inserted, updated or removed from the repository.","You can also remove an event listener from a collection."]},{"l":"CollectionEventInfo","p":["More on CollectionEventInfo can be found here."]},{"l":"Attributes","p":["Attributes is a metadata information associated with a repository.","You can get/set attributes on a repository. The attributes are stored in the database and can be retrieved later. The attributes are stored in a special map named $nitrite_meta_map."]},{"l":"Processors","p":["Processor can be used to process the underlying documents of a repository. More on processors can be found here."]},{"l":"Registering a Processor","p":["You can register a processor on a repository using addProcessor() method. It takes a Processor as input parameter."]},{"l":"Available Processors","p":["Nitrite provides a StringFieldEncryptionProcessor which can be used to encrypt a field before writing it into a repository and decrypt a field after reading it from a repository.","More on this is described in Support."]}],[{"l":"Filters","p":["Filters are used to specify the criteria used to select documents from a collection or repository. It provides a way to specify conditions that the documents must meet to be included in the result set. Filters are used in conjunction with the find method. The find method returns all documents in a collection that match the specified filtering criteria.","Each filtering criteria is based on a field in the document. If the field is indexed, the find operation takes advantage of the index to speed up the operation. If the field is not indexed, the find operation scans the entire collection to find matching documents."]},{"l":"Fluent API","p":["Nitrite provides a fluent API to create filters via FluentFilter class. It provides a static where method that creates a new FluentFilter instance with the specified field name. Here's an example:","In this example, the FluentFilter.where method is used to create a filter that matches documents where the name field equals \"John\". The filter is then passed to the find method to retrieve the matching documents.","For spatial filters, use the SpatialFluentFilter class for the fluent API. It provides a static where method that creates a new SpatialFluentFilter instance with the specified field name. Here's an example:","More on spatial module can be found here."]},{"l":"Usage","p":["Filters are used with the find method of NitriteCollection or ObjectRepository to retrieve documents that match the filter. Here's an example:","In this example, the where and eq methods are used to create an equality filter that matches documents where the name field equals \"John\". The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Types of Filters","p":["Nitrite filters can be grouped into the following categories:","Comparison filters","Logical filters","Array filters","Evaluation filters","Spatial filters"]},{"l":"Comparison Filters","p":["Comparison filters are used to compare a field with a value. The following comparison filters are supported:","Equality (eq): Matches all documents where the value of the field equals the specified value.","Inequality (notEq): Matches all documents where the value of the field is not equal to the specified value.","Greater than (gt): Matches all documents where the value of the field is greater than the specified value.","Greater than or equal to (gte): Matches all documents where the value of the field is greater than or equal to the specified value.","Less than (lt): Matches all documents where the value of the field is less than the specified value.","Less than or equal to (lte): Matches all documents where the value of the field is less than or equal to the specified value.","In (in): Matches all documents where the value of the field equals any value in the specified array.","Not in (notIn): Matches all documents where the value of the field does not equal any value in the specified array.","Between (between): Matches all documents where the value of the field is between the specified values.","All (all): Matches all documents in the collection."]},{"l":"Equality Filter","p":["The equality filter is used to match documents where the value of a field equals the specified value. The following example shows how to use the equality filter:","In this example, the where() and eq() methods are used to create an equality filter that matches documents where the name field equals \"John\". The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Inequality Filter","p":["The inequality filter is used to match documents where the value of a field is not equal to the specified value. The following example shows how to use the inequality filter:","In this example, the where() and notEq() methods are used to create an inequality filter that matches documents where the name field does not equal \"John\". The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Greater Than Filter","p":["The greater than filter is used to match documents where the value of a field is greater than the specified value. The following example shows how to use the greater than filter:","In this example, the where() and gt() methods are used to create a greater than filter that matches documents where the age field is greater than 18. The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Greater Than or Equal To Filter","p":["The greater than or equal to filter is used to match documents where the value of a field is greater than or equal to the specified value. The following example shows how to use the greater than or equal to filter:","In this example, the where() and gte() methods are used to create a greater than or equal to filter that matches documents where the age field is greater than or equal to 18. The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Less Than Filter","p":["The less than filter is used to match documents where the value of a field is less than the specified value. The following example shows how to use the less than filter:","In this example, the where() and lt() methods are used to create a less than filter that matches documents where the age field is less than 18. The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Less Than or Equal To Filter","p":["The less than or equal to filter is used to match documents where the value of a field is less than or equal to the specified value. The following example shows how to use the less than or equal to filter:","In this example, the where() and lte() methods are used to create a less than or equal to filter that matches documents where the age field is less than or equal to 18. The filter is then passed to the find method to retrieve the matching documents."]},{"l":"In Filter","p":["The in filter is used to match documents where the value of a field equals any value in the specified array. The following example shows how to use the in filter:","In this example, the where() and in() methods are used to create an in filter that matches documents where the name field equals \"John\" or \"Jane\". The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Not In Filter","p":["The not in filter is used to match documents where the value of a field does not equal any value in the specified array. The following example shows how to use the not in filter:","In this example, the where() and notIn() methods are used to create a not in filter that matches documents where the name field does not equal \"John\" or \"Jane\". The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Between Filter","p":["The between filter is used to match documents where the value of a field is between the specified values. The following example shows how to use the between filter:","In this example, the where() and between() methods are used to create a between filter that matches documents where the age field is between 18 and 30. The filter is then passed to the find method to retrieve the matching documents.","There are three overloaded versions of the between filter. The first version takes two parameters, the lower and upper bounds of the range. The second version takes an additional boolean parameter that indicates whether both the lower and upper bounds are inclusive or exclusive. The third version takes two additional boolean parameters that indicate whether the lower and upper bounds are inclusive or exclusive. The following example shows how to use the second version of the between filter:","In this example, the where() and between() methods are used to create a between filter that matches documents where the age field is between 18 and 30. Both the lower and upper bounds are inclusive. The filter is then passed to the find method to retrieve the matching documents.","The following example shows how to use the third version of the between filter:","In this example, the where() and between() methods are used to create a between filter that matches documents where the age field is between 18 and 30. The lower bound is inclusive and the upper bound is exclusive. The filter is then passed to the find method to retrieve the matching documents."]},{"l":"All Filter","p":["The all filter is used to match all documents in the collection. The following example shows how to use the all filter:","In this example, the Filter.ALL constant is used to create an all filter that matches all documents in the collection. The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Logical Filters","p":["Logical filters are used to combine multiple filters into a single filter. The following logical filters are supported:","And (and): Matches all documents that satisfy all the specified filters.","Or (or): Matches all documents that satisfy at least one of the specified filters.","Not (not): Matches all documents that do not satisfy the specified filter."]},{"l":"And Filter","p":["The and filter is used to match documents that satisfy all the specified filters. The following example shows how to use the and filter:","In this example, the where() and eq() methods are used to create an equality filter that matches documents where the name field equals \"John\". The where() and gt() methods are used to create a greater than filter that matches documents where the age field is greater than 18. The two filters are then combined using the and() method to create an and filter that matches documents where the name field equals \"John\" and the age field is greater than 18. The filter is then passed to the find method to retrieve the matching documents.","The and() method can be used to combine any number of filters. The following example shows how to combine three filters:","The static Filter.and() method can also be used to combine multiple filters into a single filter. The following example shows how to combine two filters into a single filter:","In this example, the and() method is used to combine three filters into a single filter. The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Or Filter","p":["The or filter is used to match documents that satisfy at least one of the specified filters. The following example shows how to use the or filter:","In this example, the where() and eq() methods are used to create an equality filter that matches documents where the name field equals \"John\". The where() and gt() methods are used to create a greater than filter that matches documents where the age field is greater than 18. The two filters are then combined using the or() method to create an or filter that matches documents where the name field equals \"John\" or the age field is greater than 18. The filter is then passed to the find method to retrieve the matching documents.","The or() method can be used to combine any number of filters. The following example shows how to combine three filters:","The static Filter.or() method can also be used to combine multiple filters into a single filter. The following example shows how to combine two filters into a single filter:","In this example, the or() method is used to combine three filters into a single filter. The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Not Filter","p":["The not filter is used to match documents that do not satisfy the specified filter. The following example shows how to use the not filter:","In this example, the where() and eq() methods are used to create an equality filter that matches documents where the name field equals \"John\". The not() method is then used to create a not filter that matches documents where the name field does not equal \"John\". The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Array Filters","p":["Array filters are used to match documents based on the values in an array field. The following array filters are supported:","Element match (elemMatch): Matches all documents where the array field contains at least one element that matches the specified filter."]},{"l":"Element Match Filter","p":["The element match filter is used to match documents where the array field contains at least one element that matches the specified filter. The following example shows how to use the element match filter:","Let's say we have a collection that contains documents with the following structure:","The following example shows how to use the element match filter to find all documents where the addresses field contains at least one element that matches the filter where the city field equals \"New York\":","In this example, the where() and elemMatch() methods are used to create an element match filter that matches documents where the addresses field contains at least one element that matches the filter where the city field equals \"New York\". The filter is then passed to the find method to retrieve the matching documents.","The elemMatch filter can be used to search an array of elements for a specific value. The following example shows how to use the elemMatch filter to find all documents where the data field contains at least one element that is greater than 2 or less than equal to 5:","The static FluentFilter.$ is used to refer to the current element in the array. The $.gt(2).or($.lte(5)) filter is used to match documents where the data field contains at least one element that is greater than 2 or less than equal to 5. The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Evaluation Filters","p":["Evaluation filters are used to match documents based on evaluating the value of any field in a document. The following evaluation filters are supported:","Text (text): Matches all documents which contain a specified full-text search expression.","Regex (regex): Matches all documents where values contain a specified regular expression."]},{"l":"Text Filter","p":["The text filter is used to match documents which contain a specified full-text search expression. The following example shows how to use the text filter:","In this example, the where() and text() methods are used to create a text filter that matches documents where the name field contains the word \"John\". The filter is then passed to the find method to retrieve the matching documents.","The text filter can only be used with a field that has a full-text index."]},{"l":"Regex Filter","p":["The regex filter is used to match documents where values contain a specified regular expression. The following example shows how to use the regex filter:","In this example, the where() and regex() methods are used to create a regex filter that matches documents where the name field matches the regular expression \"John.*\". The filter is then passed to the find method to retrieve the matching documents.","This filter scans the entire collection to find matching documents. It cannot take advantage of an index."]},{"l":"Spatial Filters","p":["Spatial filters are used to match documents based on the values in a spatial field. The following spatial filters are supported:","Near (near): Matches all documents where the spatial field is within the specified distance from the specified point.","Within (within): Matches all documents where the spatial field is within the specified shape.","Intersects (intersects): Matches all documents where the spatial field intersects the specified shape.","To use spatial filters, you need create a spatial index on the field, which needs the nitrite-spatial module to be loaded. More on this can be found here."]},{"l":"Near Filter","p":["The near filter is used to match documents where the value of the spatial field is near the specified point. The following example shows how to use the near filter:","In this example, the where() and near() methods are used to create a near filter that matches documents where the location field is within 1000 meters of the point (40.730610, -73.935242). The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Within Filter","p":["The within filter is used to match documents where the value of the spatial field is within the specified shape. The following example shows how to use the within filter:","In this example, the where() and within() methods are used to create a within filter that matches documents where the location field is within the polygon ((0 0, 0 3, 3 3, 3 0, 0 0)). The filter is then passed to the find method to retrieve the matching documents."]},{"l":"Intersects Filter","p":["The intersects filter is used to match documents where the value of the spatial field intersects the specified shape. The following example shows how to use the intersects filter:","In this example, the where() and intersects() methods are used to create an intersects filter that matches documents where the location field intersects the polygon ((0 0, 0 3, 3 3, 3 0, 0 0)). The filter is then passed to the find method to retrieve the matching documents."]}],[{"l":"Transaction","p":["A transaction is a single logical unit of work which accesses and possibly modifies the contents of a database. Transactions access data using read and write operations.","Nitrite supports transactional operations on its collections and repositories. A transaction can be committed or rolled back. Once a transaction is committed, all the changes are persisted to the disk. If a transaction is rolled back, all the changes are discarded."]},{"l":"Transaction on NitriteCollection","p":["A transaction can be started from a session using the Session.beginTransaction() method. To start a transactional operation on a NitriteCollection, the Transaction.getCollection() method can be used. All the operations performed on the collection will be part of the transaction.","Transaction is a closeable resource. It is recommended to use it with try-with-resource block.","Any find operations performed inside a transaction will return all the documents including the uncommitted ones.","Any find operations performed outside a transaction will return only the committed documents."]},{"l":"Auto-commit Operations","p":["Certain operations are auto-committed in Nitrite. Those operations are not part of a transaction and cannot be rolled back. The following operations are auto-committed:","NitriteCollection.createIndex()","NitriteCollection.rebuildIndex()","NitriteCollection.dropIndex()","NitriteCollection.dropAllIndices()","NitriteCollection.drop()","NitriteCollection.clear()","NitriteCollection.close()"]},{"l":"Transaction on ObjectRepository","p":["A transaction can be started from a session using the Session.beginTransaction() method. To start a transactional operation on a ObjectRepository, the Transaction.getRepository() method can be used. All the operations performed on the repository will be part of the transaction.","Transaction is a closeable resource. It is recommended to use it with try-with-resource block.","Any find operations performed inside a transaction will return all the entities including the uncommitted ones.","Any find operations performed outside a transaction will return only the committed entities."]},{"i":"auto-commit-operations-1","l":"Auto-commit Operations","p":["Certain operations are auto-committed in Nitrite. Those operations are not part of a transaction and cannot be rolled back. The following operations are auto-committed:","ObjectRepository.createIndex()","ObjectRepository.rebuildIndex()","ObjectRepository.dropIndex()","ObjectRepository.dropAllIndices()","ObjectRepository.drop()","ObjectRepository.clear()","ObjectRepository.close()"]},{"l":"Session","p":["A session represents a transactional context for a Nitrite database. Session is used to create a new transaction. A session should be closed after use to release any resources held by it. If a session is closed and the transaction is not committed, all opened transactions will be rolled back."]},{"l":"Create a Session","p":["A session can be created using the Nitrite.createSession() method. Multiple sessions can be created for a Nitrite database."]},{"l":"Close a Session","p":["A session can be closed using the Session.close() method. If a session is closed and the transaction is not committed, all opened transactions will be rolled back."]},{"l":"Checking Session State","p":["The current state of a session can be checked using the Session.checkState() method. If the session is not active, it will throw an TransactionException."]},{"l":"Managing Transactions","p":["A transaction can be started using the Session.beginTransaction() method.","A transaction can be committed using the Transaction.commit() method. If a transaction is committed, all the changes are persisted to the disk.","A transaction can be rolled back using the Transaction.rollback() method. If a transaction is rolled back, all the changes are discarded.","A transaction can be closed using the Transaction.close() method. If a transaction is closed and the transaction is not committed, all opened transactions will be rolled back."]},{"l":"Querying Transaction State","p":["The current state of a transaction can be retrieved using the Transaction.getState() method. It returns an enum of type TransactionState."]}],[{"l":"Schema Migration","p":["A migration is a set of changes to the schema that can be applied to a database. Migrations are used to keep the database schema up to date with the codebase. It contains a queue of instructions that are executed in order to update the database schema from one version to the next.","The migration is executed only once. If you want to execute the migration again, you need to change the schema version of the database.","For example, if you have a database with the schema version 1 and you want to update it to version 2, you need to apply the migration steps from version 1 and version 2.","The migration instructions are executed in the order they are added to the migration. The order of the instructions is important. For example, if you want to rename a field, you need to add the renameField instruction before the deleteField instruction. Otherwise, the deleteField instruction will fail.","Once a migration is applied to a database, it cannot be reverted. If you want to revert a migration, you need to create a new migration that will revert the changes.","Nitrite provides a set of instructions that can be used to update the database schema. These instructions can be grouped into three categories:","Database Instruction","Collection Instruction","Repository Instruction"]},{"l":"Database Instruction","p":["Database instructions are used to perform operations on the database. The following instructions are available:"]},{"l":"Add User","p":["Adds an instruction to set a user authentication to the database. The user will be used to open the database.","Nitrite database supports only one user authentication per database. If you try to add a new user when there is already a user authentication present, the migration will fail throwing a NitriteSecurityException."]},{"l":"Change Password","p":["Adds an instruction to change the password for the user authentication to the database.","The user authentication must be present in the database. If you try to change the password for a user that does not exist, the migration will fail throwing a NitriteSecurityException.","If you try to change the password for a user with a wrong password, the migration will also fail throwing a NitriteSecurityException."]},{"l":"Drop Collection","p":["Adds an instruction to drop a NitriteCollection from the database."]},{"l":"Drop Repository","p":["Adds an instruction to drop a ObjectRepository from the database. There are several ways to drop a repository:"]},{"l":"Drop by Class"},{"l":"Drop by Class and Key Name"},{"l":"Drop by EntityDecorator"},{"l":"Drop by EntityDecorator and Key Name"},{"l":"Drop by Repository Type Name"},{"l":"Drop by Repository Type Name and Key Name"},{"l":"Custom Instruction","p":["Adds a custom instruction to perform a user defined operation on the database."]},{"l":"Collection Instruction","p":["Collection instructions are used to perform operations on a NitriteCollection. The following instructions are available:"]},{"l":"Rename Collection","p":["Adds an instruction to rename a NitriteCollection."]},{"l":"Add Field","p":["Adds an instruction to add new field to the documents of a NitriteCollection."]},{"l":"Add Field with Null Value","p":["The new field will be added to all the documents of the collection. The value of the new field will be null."]},{"l":"Add Field with Default Value","p":["The new field will be added to all the documents of the collection. The value of the new field will be new-value."]},{"l":"Add Field with Generator","p":["The new field will be added to all the documents of the collection. The value of the new field will be the value returned by the Generator."]},{"l":"Generator","p":["A Generator is a functional interface that takes a Document as input and returns a value. The value returned by the Generator function will be used as the value of the new field."]},{"l":"Rename Field","p":["Adds an instruction to rename a field of the documents of a NitriteCollection."]},{"l":"Delete Field","p":["Adds an instruction to delete a field from the documents of a NitriteCollection."]},{"l":"Drop Index","p":["Adds an instruction to drop an index from a NitriteCollection.","The drop index instruction can be used to drop a single field index or a compound index."]},{"l":"Drop All Indexes","p":["Adds an instruction to drop all the indexes from a NitriteCollection."]},{"l":"Create Index","p":["Adds an instruction to create an index on a NitriteCollection.","The create index instruction can be used to create a single field index or a compound index."]},{"l":"Repository Instruction","p":["Repository instructions are used to perform operations on a ObjectRepository. The following instructions are available:"]},{"l":"Rename Repository","p":["Adds an instruction to rename a ObjectRepository."]},{"i":"add-field-1","l":"Add Field","p":["Adds an instruction to add new field to the entity of a ObjectRepository."]},{"i":"add-field-with-null-value-1","l":"Add Field with Null Value","p":["The new field will be added to all the entities of the repository. The value of the new field will be null."]},{"i":"add-field-with-default-value-1","l":"Add Field with Default Value","p":["The new field will be added to all the entities of the repository. The value of the new field will be 0."]},{"l":"Add Field with Generator Function","p":["The new field will be added to all the entities of the repository. The value of the new field will be the value returned by the Generator function.","More information about the Generator can be found here."]},{"i":"rename-field-1","l":"Rename Field","p":["Adds an instruction to rename a field of the entity of a ObjectRepository."]},{"i":"delete-field-1","l":"Delete Field","p":["Adds an instruction to delete a field from the entity of a ObjectRepository."]},{"l":"Change Data Type","p":["Adds an instruction to change the data type of a field of the entity of a ObjectRepository."]},{"l":"Type Converter","p":["A TypeConverter is a functional interface that takes a value of one type as input and returns a value of another type. The value returned by the TypeConverter function will be used as the value of the new field."]},{"l":"Change Id Field","p":["Adds an instruction to change the id field of the entity of a ObjectRepository."]},{"i":"drop-index-1","l":"Drop Index","p":["Adds an instruction to drop an index from a ObjectRepository.","The drop index instruction can be used to drop a single field index or a compound index."]},{"i":"drop-all-indexes-1","l":"Drop All Indexes","p":["Adds an instruction to drop all the indexes from a ObjectRepository."]},{"i":"create-index-1","l":"Create Index","p":["Adds an instruction to create an index on a ObjectRepository.","The create index instruction can be used to create a single field index or a compound index."]}],[{"l":"Module System","p":["Nitrite is a modular database engine. The core functionality of Nitrite is provided by the nitrite module. The nitrite module is the only mandatory module for Nitrite. All other modules are optional and can be added to the project as per the requirement.","Nitrite's module system is built on top of NitritePlugin and NitriteModule interfaces. A module is a collection of plugins. While opening a database, all the modules must be loaded. Each module then load and initialize all the plugins it contains.","The nitrite module provides default implementation of all the interfaces. For example, the nitrite module provides in-memory storage implementation. If you want to use on-disk storage, you need to add a storage module to your project.","The main advantage of Nitrite's module system is that it allows you to extend the functionality of Nitrite without adding all the dependencies at once in your project. You only need to add dependencies that you want to use. This helps to keep the application size small.","You can write your own module and plugin and add it to the project. The module system also allows you to replace the default implementation of any plugin. For example, if you want to use a different storage engine, you can write your own storage module and add it to the project."]},{"l":"NitriteModule","p":["The NitriteModule interface is the base interface for all the modules. It encapsulates a set of plugins. A module must be loaded before opening a database.","To create a module, you need to implement the NitriteModule interface. The NitriteModule interface has a single method plugins which returns a set of plugins."]},{"l":"Dynamic Module","p":["A dynamic module can be created using the static module method of the NitriteModule interface. A dynamic module is a module which is not loaded from a jar file. It is created at runtime.","A dynamic module is useful when you want to create a module from a set of plugins at runtime."]},{"l":"Available Modules","p":["The following modules are available from Nitrite.","Storage Module","Jackson Module","Geo-spatial Module"]},{"l":"NitritePlugin","p":["The NitritePlugin interface is the base interface for all the plugins. A plugin is a single unit of functionality. A plugin must be loaded via a NitriteModule before opening a database."]},{"l":"Initializing Plugin","p":["A plugin can be initialized by implementing the initialize method of the NitritePlugin interface. The initialize method is called by the module when the plugin is loaded."]},{"l":"Closing Plugin","p":["A NitritePlugin is a closable resource. The close method is called by the Nitrite when the plugin is unloaded to release any resources held by the plugin."]},{"l":"Available Plugins","p":["Following are the available plugins in Nitrite which can be used to extend the functionality of Nitrite:","NitriteStore- A plugin to provide storage functionality.","NitriteMapper- A plugin to provide object mapping functionality.","NitriteIndexer- A plugin to provide indexing functionality.","You can implement any of the above plugins to extend the functionality of Nitrite."]},{"l":"NitriteStore","p":["The NitriteStore interface is the base interface for all the storage plugins. A storage plugin is responsible for storing and retrieving data from the underlying storage. The NitriteStore interface extends the NitritePlugin interface.","A reference implementation of the NitriteStore interface can be found here."]},{"l":"NitriteMapper","p":["The NitriteMapper interface is the base interface for all the object mapping plugins. A mapper plugin is responsible for mapping an object to a document and vice-versa. The NitriteMapper interface extends the NitritePlugin interface.","JacksonMapper is one of the available mapper plugins in Nitrite. It uses Jackson to map an object to a document and vice-versa. You can find more information about JacksonMapper here."]},{"l":"NitriteIndexer","p":["The NitriteIndexer interface is the base interface for all the indexing plugins. An indexer plugin is responsible for indexing a document. The NitriteIndexer interface extends the NitritePlugin interface.","While creating a new index, Nitrite uses the getIndexType() method of the NitriteIndexer interface to determine the type of the index. The getIndexType() method returns a string which represents the type of the index. So when you create a new index, you need to pass the same string to the IndexOptions.indexType."]},{"l":"Nitrite Bill of Materials","p":["The nitrite-bom is a bill of materials (BOM) for Nitrite. It is a pom file that contains the version of all the modules. It is useful when you want to use multiple modules in your project and want to keep the version of all the modules in sync."]},{"l":"Maven","p":["Add the nitrite dependency to your pom.xml file:"]},{"l":"Gradle","p":["Add the nitrite dependency to your build.gradle file:"]}],[{"l":"Storage Module","p":["Nitrite provides a default storage module which is in-memory. It means all the data is stored in memory and is volatile. Once the application is closed, all the data is lost. If you want to persist the data, you want to use on-disk storage, you need to add a storage module to your project. There are choices of storage modules available for Nitrite. You can choose any one of them as per your requirement.","MVStore Module","RocksDB Module","You can also write your own storage module and add it to the project. More details about writing your own storage module is available here."]}],[{"l":"MVStore Modules","p":["Nitrite provides a persistent storage module based on MVStore. MVStore is a pure Java key-value store database. It is a single file based database. It is very fast and lightweight."]},{"l":"Adding MVStore Module","p":["Add MVStore module to your project:"]},{"l":"Maven","p":["Add the MVStore dependency to your pom.xml file:"]},{"l":"Gradle","p":["Add the MVStore dependency to your build.gradle file:"]},{"l":"Using MVStore Module","p":["To use MVStore as your persistent storage, you need to load the MVStoreModule while opening the database. You can also configure the module as per your requirement.","Once the module is loaded, you can use the database as usual. All the data will be persisted in the file you specified."]},{"l":"Configuring MVStore Module","p":["You can configure the MVStore module as per your requirement. The following configuration options are available:","filePath- the file path where the database will be stored.","autoCommitBufferSize- the size of the buffer used for auto-commit. When the buffer is full, the changes are automatically committed to the database. The default buffer size is 1024.","encryptionKey- the encryption key used to encrypt the database. If not specified, the database will not be encrypted.","readOnly- if set to true, the database will be opened in read-only mode. The default value is false.","compress- if set to true, the database will be compressed. The default value is false.","compressHigh- if set to true, the database will be compressed using high compression. The default value is false. It may result in slower read and write performance but smaller file size on disk.","autoCommit- if set to true, all changes will be committed immediately. If set to false, changes will be buffered until the buffer is full or Nitrite.commit() is called. The default value is true.","recoveryMode- if set to true, the database will be opened in recovery mode. The default value is false.","cacheSize- the cache size in MB. The default value is 16 MB.","cacheConcurrency- the read cache concurrency used by MVStore. Default is 16 segments.","pageSplitSize- the amount of memory a MVStore page should contain at most, in bytes, before it is split. The default is 16 KB.","fileStore- the file store used by MVStore.","Nitrite provides a builder pattern to configure the module. You can use the MVStoreModule.withConfig() method to get the builder instance. The builder has a build() method which returns the configured module."]},{"i":"upgrading-from-3x","l":"Upgrading from 3.x","p":["If you are upgrading from Nitrite 3.x, you need to use the MVStore module as your storage module if you want to automatically upgrade your database. Any other storage module will not be able to upgrade your database automatically; you need to write your own upgrade logic.","Nitrite 3.x uses MVStore version 1.4.x. Nitrite 4.x uses MVStore version 2.2.x. The MVStore version 2.2.x is not backward compatible with version 1.4.x. So, Nitrite 4.x will try to upgrade your database automatically when you open it for the first time on a . If the upgrade fails, you need to write your own upgrade logic. However, it is recommended to take a backup of your database before upgrading."]}],[{"l":"RocksDB Module","p":["Nitrite provides a persistent storage module based on RocksDB. RocksDB is a persistent key-value store for fast storage. It is based on a log-structured merge-tree (LSM tree) data structure. It is very fast and lightweight. Nitrite uses the JNI wrapper of RocksDB.","RocksDB's column family feature is used to store the data of each collection."]},{"l":"Adding RocksDB Module","p":["Add RocksDB module to your project:"]},{"l":"Maven","p":["Add the RocksDB dependency to your pom.xml file:"]},{"l":"Gradle","p":["Add the RocksDB dependency to your build.gradle file:"]},{"l":"Using RocksDB Module","p":["To use RocksDB as your persistent storage, you need to load the RocksDBModule while opening the database. You can also configure the module as per your requirement.","Once the module is loaded, you can use the database as usual. All the data will be persisted in the file you specified."]},{"l":"Configuring RocksDB Module","p":["You can configure the RocksDB module as per your requirement. The following configuration options are available:","filePath- the file path where the database will be stored.","options- the RocksDB's Options object. You can configure RocksDB as per your requirement. The default value is null.","dbOptions- the RocksDB's DBOptions object. You can configure RocksDB as per your requirement. The default value is null.","columnFamilyOptions- the RocksDB's ColumnFamilyOptions object. You can configure RocksDB as per your requirement. The default value is null.","objectFormatter- the ObjectFormatter to be used to serialize/deserialize objects. The default implementation is KryoObjectFormatter which is based on Kryo serializer."]},{"l":"Object Serialization","p":["RocksDB is a key-value store database. It stores data in byte array format. To store objects in RocksDB, Nitrite uses a serializer. Nitrite uses ObjectFormatter to serialize/deserialize objects. The default implementation is KryoObjectFormatter which is based on Kryo serializer. You can also provide your own implementation of ObjectFormatter to serialize/deserialize objects."]},{"l":"Implementing ObjectFormatter","p":["To implement your own ObjectFormatter, you need to implement the ObjectFormatter interface.","Once you have implemented the ObjectFormatter, you can use it while configuring the RocksDB module.","Normally, you don't need to implement your own ObjectFormatter. The default implementation is good enough for most of the use cases."]}],[{"l":"Custom Storage Modules","p":["The beauty of Nitrite is that it is highly extensible. You can write your own storage module and use it with Nitrite. Nitrite provides a simple interface StoreModule to write your own storage module."]},{"l":"StoreModule Interface","p":["To write a custom storage module, you need to implement the StoreModule interface. The interface has only one method getStore() which returns an implementation of NitriteStore interface.","Optionally, you can also implement the StoreConfig interface to provide configuration options for your storage module."]},{"l":"NitriteStore Interface","p":["The NitriteStore is the storage abstraction layer for Nitrite. It provides the basic operations required by Nitrite to store and retrieve data. A NitriteStore is responsible for managing NitriteMap and NitriteRTree instances which are the main building blocks of database collections."]},{"l":"StoreConfig Interface","p":["The StoreConfig interface provides configuration options for your storage module. You can use this interface to provide configuration options for your storage module."]},{"l":"NitriteMap Interface","p":["The NitriteMap interface is the abstraction layer for Nitrite's key-value store. It provides the basic operations required by a collection to store and retrieve data. A NitriteMap is responsible for managing NitriteId and Document instances which are the main unit of data storage in Nitrite."]},{"l":"NitriteRTree Interface","p":["The NitriteRTree interface is the abstraction layer for Nitrite's R-Tree. It provides the basic operations required by a spatial index to store and retrieve data."]},{"l":"Example","p":["Let's write a simple storage module which stores data in a Map object. The module will be a simple in-memory storage module. The module will be configured with a Map object and will use it to store data."]},{"l":"Store Module","p":["The following code snippet shows the implementation of the storage module."]},{"l":"Store Config","p":["The following code snippet shows the implementation of the store configuration.","And the builder class for the configuration."]},{"l":"Nitrite Store","p":["The following code snippet shows the implementation of the NitriteStore interface."]},{"l":"Nitrite Map","p":["The following code snippet shows the implementation of the NitriteMap interface."]},{"l":"Nitrite RTree","p":["The following code snippet shows the implementation of the NitriteRTree interface."]}],[{"l":"Spatial Module","p":["Nitrite Spatial module provides support for spatial queries. The module uses JTS library for spatial operations."]},{"l":"Adding Spatial Module","p":["Add Spatial module to your project:"]},{"l":"Maven","p":["Add the Spatial dependency to your pom.xml file:"]},{"l":"Gradle","p":["Add the Spatial dependency to your build.gradle file:"]},{"l":"Using Spatial Module","p":["To use Spatial module, you need to load the SpatialModule while opening the database."]},{"l":"Using Spatial Modules with Jackson","p":["If you are using Jackson module for serialization, you need to register the GeometryModule with Jackson as well.","The GeometryModule is required to serialize the Geometry object of JTS via Jackson."]},{"l":"Spatial Index","p":["Spatial module uses R-Tree index to store the spatial data.","To create a spatial index, you need to pass the index type as SpatialIndexer.SPATIAL_INDEX while creating the index."]},{"l":"Spatial Filter","p":["Spatial module supports several filters to query spatial data. To know more about filters, please refer to Spatial Filters."]}],[{"l":"Jackson Mapper Module","p":["Nitrite provides a Jackson mapper module to convert Java objects to Document and vice-versa. The module is useful when you don't want to use the EntityConverter interface to map Java objects to Document and vice-versa."]},{"l":"Adding Jackson Mapper Module","p":["Add the Jackson mapper module to your project:"]},{"l":"Maven","p":["Add the Jackson mapper module dependency to your pom.xml file:"]},{"l":"Gradle","p":["Add the Jackson mapper module dependency to your build.gradle file:"]},{"l":"Using Jackson Mapper Module","p":["To use Jackson mapper module, you need to load the JacksonMapperModule while opening the database."]},{"l":"Using Custom Jackson Modules","p":["If you want to register any custom Jackson module, you can do so by passing the module to JacksonMapperModule constructor.","If you want to register multiple modules, you can do so by passing an array of modules to JacksonMapperModule constructor.","And here is an example of a custom Jackson module."]},{"l":"Customizing ObjectMapper","p":["If you want to customize the ObjectMapper used by the Jackson mapper module, you can do so by extending the JacksonMapper class and overriding the getObjectMapper() method.","Now, you can use this custom mapper while building the database."]}],[{"l":"Usage","p":["Nitrite provides some additional functionalities via nitrite-support library. You can use the library to enable encryption, import/export database, and database recovery."]},{"l":"Adding nitrite-support","p":["Add the nitrite-support dependency to your project:"]},{"l":"Maven","p":["Add the nitrite-support dependency to your pom.xml file:"]},{"l":"Gradle","p":["Add the nitrite-support dependency to your build.gradle file:"]}],[{"i":"importexport","l":"Import/Export","p":["Nitrite provides import/export functionality via nitrite-support library. You can import/export your database to/from a file in JSON format. You can choose to import/export the entire database or a specific collection."]},{"l":"Exporting Database","p":["To export the entire database in JSON format, you can use the Exporter class of nitrite-support library. You can construct an instance of Exporter from an ExportOptions instance using Exporter.withOptions() method. The ExportOptions class provides various options to configure the export process.","The exportTo() method can take a File or a String or an OutputStream or a Writer as an argument. If you pass a File or a String argument, the exporter will create a FileOutputStream and write the exported data to the file. If you pass an OutputStream or a Writer argument, the exporter will write the exported data to the stream or writer.","The database must be in closed state before exporting."]},{"l":"Export Options","p":["collections- the list of collections to export. The rules for specifying the collection names are as follows:","exportData- whether to export data or not. It's an optional field, if not provided, it will be set to true.","exportIndices- whether to export indices or not. It's an optional field, if not provided, it will be set to true.","If a non-empty list is specified, only the collections in the list will be exported.","If a non-empty list is specified, only the repositories in the list will be exported.","If a non-empty map is specified, only the keyed repositories in the map will be exported.","If an empty list is specified, no collection will be exported.","If an empty list is specified, no repository will be exported.","If an empty map is specified, no keyed repository will be exported.","If null is specified, all collections will be exported.","If null is specified, all keyed repositories will be exported.","If null is specified, all repositories will be exported.","jsonFactory- the JsonFactory instance to use for export. It is used to create the JsonGenerator instance for export. It's an optional field, if not provided, a default one will be used.","keyedRepositories- the map of keyed repositories to export. The rules for specifying the keyed repository names are as follows:","nitriteFactory- the NitriteFactory instance to use for export. It is used to create the Nitrite instance for export. It's a mandatory field.","repositories- the list of repositories to export. The rules for specifying the repository names are as follows:","The ExportOptions class provides various options to configure the export process. You can set the following options:"]},{"l":"Example","p":["First create a method to create a Nitrite instance, which will be used as the nitriteFactory.","Then create the ExportOptions instance and configure it.","Then create the Exporter instance and export the database.","The test.json file will contain the exported data."]},{"l":"Importing Database","p":["To import the entire database from an exported JSON data, you can use the Importer class of nitrite-support library. You can construct an instance of Importer from an ImportOptions instance using Importer.withOptions() method. The ImportOptions class provides various options to configure the import process.","The importFrom() method can take a File or a String or an InputStream or a Reader as an argument. If you pass a File or a String argument, the importer will create a FileInputStream and read the exported data from the file. If you pass an InputStream or a Reader argument, the importer will read the exported data from the stream or reader.","The database must be in closed state before importing."]},{"l":"Import Options","p":["The ImportOptions class provides various options to configure the import process. You can set the following options:","nitriteFactory- the NitriteFactory instance to use for import. It is used to create the Nitrite instance for import. It's a mandatory field.","jsonFactory- the JsonFactory instance to use for import. It is used to create the JsonParser instance for import. It's an optional field, if not provided, a default one will be used."]},{"i":"example-1","l":"Example","p":["First create a ImportOptions instance and configure it using the createDb() method from the previous example.","Then create the Importer instance and import the database.","The new-test.db file will contain the imported data. You can open the database and use it."]}],[{"l":"Encryption","p":["Nitrite provides encryption support via nitrite-support module. You can encrypt your data using a password. Nitrite provides an Encryptor interface to encrypt and decrypt data. Nitrite also provides an AES based implementation of Encryptor interface, which uses AES/GCM/NoPadding algorithm to encrypt and decrypt data."]},{"l":"Using Encryption","p":["To use encryption, you can either use the AES implementation of Encryptor interface or you can create your own implementation of Encryptor interface."]},{"l":"Using AES Encryptor","p":["To use AES based encryption you need to use the AESEncryptor class. The class takes a password as a parameter in its constructor.","There is another constructor also which takes a password along with the algorithm, tag length, IV length, and salt length.","You can use the encryptor to encrypt and decrypt data."]},{"l":"Using Custom Encryptor","p":["If you want to use your own encryption algorithm, you can do so by implementing the Encryptor interface. The interface has two methods encrypt and decrypt. You can implement these methods to encrypt and decrypt data."]},{"l":"Field Level Encryption","p":["Nitrite provides field level encryption support. You can encrypt a field of a document using a password. Nitrite provides an StringFieldEncryptionProcessor utility class to encrypt and decrypt a field of a document. It uses the Encryptor interface to encrypt and decrypt data."]},{"l":"Using Field Encryption","p":["To use field encryption, you need to create an instance of StringFieldEncryptionProcessor class. The class takes either an Encryptor instance or a password as a parameter in its constructor.","If you provide the password, the class will create an instance of AESEncryptor class using the password. If you provide an Encryptor instance, the class will use the provided Encryptor instance.","You can also use the AESEncryptor class to create an instance of StringFieldEncryptionProcessor class.","The encrypted data is a base64 encoded string of the encrypted bytes."]}],[{"i":"#","p":["This guide will help you get started with Nitrite database. It will show you how to create a database, create a collection, insert documents, and query documents in Kotlin."]},{"l":"Getting Started in Kotlin","p":["Nitrite's Kotlin SDK is a wrapper around the Java SDK. It provides some Kotlin friendly extensions for some of the Java API to work with Nitrite database. The Kotlin SDK is available as a separate module named potassium-nitrite(KNO 2). In this guide, we will discuss the Kotlin specific API only. For rest of the API, please refer to the Java SDK. So it is highly recommended to go through the Java SDK guide first.","To get started with Nitrite database, you need to add the Nitrite BOM to your project. The BOM will help you to manage the dependencies. Details of the BOM can be found here.","To add the BOM to your project, follow the steps below:"]},{"l":"Add dependency","p":["To enable Kotlin support, you need to add the potassium-nitrite library to your project. It will automatically add the nitrite library as a dependency along with nitrite-spatial and nitrite-jackson-mapper libraries."]},{"l":"Maven","p":["Add the nitrite dependency to your pom.xml file:"]},{"l":"Gradle","p":["Add the nitrite dependency to your build.gradle file:","The latest released version of Nitrite can be found here."]},{"l":"Snapshot builds","p":["Snapshot builds are available from Sonatype.","To use snapshot builds, you need to add the snapshot repository to your pom.xml or build.gradle file:"]},{"i":"maven-1","l":"Maven"},{"i":"gradle-1","l":"Gradle","p":["Nitrite's Kotlin SDK is not as lean as the Java SDK. It has a lot of dependencies. If you are using Kotlin in your project, it is recommended to use the Kotlin SDK. Otherwise, you can use the Java SDK with Kotlin as well."]},{"i":"upgrade-from-3x","l":"Upgrade from 3.x","p":["If you are upgrading from 3.x, please note that there are lots of breaking changes in the API. The whole library is re-written from scratch. It is recommended to go through this guide before upgrading.","You need to use the MVStore as your storage module to upgrade from 3.x. The RocksDB module is not backward compatible.","Nitrite will try to migrate your existing database to the latest version on the provided you are using the MVStore module. If you are using the RocksDB module, you need to migrate your database manually. However, it is recommended to take a backup of your database before upgrading."]}],[{"l":"Nitrite Database","p":["Nitrite database is a serverless, embedded, and self-contained Java NoSQL database. It is an open-source project that provides a simple API for persistent data storage. Nitrite database is designed to be lightweight, fast, and easy to use."]},{"l":"Creating a Database","p":["Nitrite database can be created in-memory or on-disk. By default, Nitrite database is created in-memory. To create a database on-disk, you need to add a storage module dependency to your project. More details about storage modules can be found here.","To create a database, you need to use nitrite() function. It is a builder function that returns an instance of Nitrite."]},{"l":"In-memory Database","p":["If you don't load any on-disk storage module, then Nitrite will create an in-memory database. The below code snippet shows how to create a database in-memory."]},{"l":"On-disk Database","p":["The below code snippet shows how to create a database on-disk."]},{"l":"MVStore Backed Database","p":["More details about MVStore configuration can be found here."]},{"l":"RocksDB Backed Database","p":["More details about RocksDB configuration can be found here."]},{"l":"Securing a Database","p":["To secure a database, you need to pass a username and password to the nitrite() function. The below code snippet shows how to secure a database.","If you are using a file-based database, then you need to use the same username and password to open the database again. Otherwise, you will get a NitriteSecurityException.","Both username and password must be provided or both must be null."]},{"l":"Registering an EntityConverter","p":["Nitrite database uses a mapper to map Kotlin/Java entities to Nitrite documents and vice-versa. By default, Nitrite uses SimpleNitriteMapper as its mapper. This mapper uses EntityConverter s to map entities to Nitrite documents and vice-versa. To register an EntityConverter, you need to call registerEntityConverter() method on Builder instance.","More details about EntityConverter can be found here."]},{"l":"Loading a Nitrite Module","p":["Nitrite database is modular in nature. It provides a set of modules to extend its functionality. To load a module, you need to call loadModule() method on Builder instance.","More details about Nitrite modules can be found here."]},{"l":"Loading a Storage Module","p":["More details about storage modules can be found here."]},{"l":"Adding Migration Steps","p":["Nitrite database supports migration from one version to another. To add a migration step, you need to call addMigration() method on Builder instance.","More details about schema migration can be found here."]},{"l":"Current Schema Version","p":["To configure the current schema version, you need to set the schemaVersion property on Builder instance.","By default, the initial schema version is set to 1."]},{"l":"Field Separator Character","p":["Nitrite database uses . as the field separator character. It is used to separate nested fields in a document. For example, if you have a document like below:","Then you can access the firstName field like below:","And you can access the street field like below:","To configure the field separator character, you need to set the fieldSeparator property on Builder instance.","By default, the field separator character is set to .."]}],[{"l":"Document","p":["Document is the basic unit of data in Nitrite database. It is a JSON like field-value pairs. The field is always a String and value can be anything including null. Document is schema-less, which means you can store any kind of data in a document.","Nitrite document supports nested document. That means, a value of a field can be another document. This allows you to create complex data structure.","More details on document can be found here."]},{"l":"Kotlin API for Document","p":["Potassium Nitrite provides a set of extension functions to make document manipulation easier."]},{"l":"Create a Document","p":["To create a document, you can use the documentOf function. It takes a vararg of PairString, Any? and returns a Document.","To create a nested document, you can use the documentOf function recursively.","To create an empty document, you can use the emptyDocument function."]},{"l":"Get a Field Value","p":["To get a field value from a document, you can use the index operator [] on the document. It takes a String as the field name and returns the value of the field."]},{"l":"Checking If a Document is Empty","p":["To check if a document is empty, you can use the isEmpty function. It takes no argument and returns a Boolean.","Conversely, to check if a document is not empty, you can use the isNotEmpty function. It takes no argument and returns a Boolean."]}],[{"l":"Nitrite Collection","p":["NitriteCollection represents a named document collection stored in a Nitrite database. It persists documents in a Nitrite database. It is similar to a table in relational database or a collection in MongoDB.","More details on collection can be found here."]},{"l":"Kotlin API for NitriteCollection","p":["Potassium Nitrite provides a higher-order function to make collection manipulation easier."]}],[{"l":"Object Repository","p":["ObjectRepository provides a simple and type-safe API for storing and retrieving Kotlin/Java objects in a Nitrite database. It is built on top of NitriteCollection and provides a similar API for CRUD operations. It also supports indexing and querying. It also supports event based notification on object changes.","More details on repository can be found here."]},{"l":"Kotlin API for ObjectRepository","p":["Potassium Nitrite provides some higher-order functions to make repository manipulation easier."]},{"l":"Creating a Repository with Class Type","p":["You can create a ObjectRepository by passing a class type to getRepository() method."]},{"l":"Creating a Repository with Class Type and Key","p":["You can create a keyed ObjectRepository by passing a class type and a key to getRepository() method.","One typical use case of this keyed repository is to create a repository for each user in a multi-user application. The key can be the user name or user id. This will ensure that each user will have a separate repository for storing objects."]},{"l":"Creating a Repository with EntityDecorator","p":["A ObjectRepository can be created using EntityDecorator. This is useful when you cannot modify the object class to add annotations.","More details about EntityDecorator can be found here."]},{"l":"Creating a Repository with EntityDecorator and Key","p":["A keyed ObjectRepository can be created using EntityDecorator and a key. This is useful when you cannot modify the object class to add annotations.","More details about EntityDecorator can be found here."]},{"l":"NitriteMapper","p":["Nitrite provides a mapper interface called NitriteMapper. It is used to map Java objects to Nitrite documents and vice-versa. More details on NitriteMapper can be found here.","Apart from the SimpleNitriteMapper, Potassium Nitrite also provides two additional mappers:","KNO2JacksonMapper","KotlinXSerializationMapper"]},{"l":"Jackson Mapper","p":["Potassium Nitrite extends the JacksonMapper to provide KNO2JacksonMapper. This class overrides the getObjectMapper() method to register some Kotlin specific Jackson modules as follows:","KotlinModule","JavaTimeModule","Jdk8Module","GeometryModule","It also disables the SerializationFeature.WRITE_DATES_AS_TIMESTAMPS feature. The constructor of KNO2JacksonMapper takes a vararg of com.fasterxml.jackson.databind.Module to register additional Jackson modules.","To use the KNO2JacksonMapper instead of the default SimpleNitriteMapper you need to load it while opening the database."]},{"l":"KotlinX Serialization Mapper","p":["Potassium Nitrite also provides a KotlinX Serialization based mapper called KotlinXSerializationMapper. KotlinX Serialization is used to convert Java/Kotlin objects to Document and vice-versa.","To use the KotlinXSerializationMapper instead of the default SimpleNitriteMapper you need to load it while opening the database."]}],[{"l":"Filters","p":["Filters are used to specify the criteria used to select documents from a collection or repository. It provides a way to specify conditions that the documents must meet to be included in the result set. Filters are used in conjunction with the find method. The find method returns all documents in a collection that match the specified filtering criteria.","More details on filters can be found here."]},{"l":"Kotlin API for Filters","p":["Potassium Nitrite provides a set of infix functions to make filter usage more like operators. It also provides a set of extension functions for KProperty so that you can use property name instead of string in case of entity class."]},{"l":"Comparison Operators","p":["Comparison operators are used to compare two expressions. More details on comparison operators can be found here."]},{"l":"Equal To","p":["To check if a field value is equal to a value, you can use the eq function.","Similarly, you can use the eq function with KProperty.","More details on eq function can be found here."]},{"l":"Not Equal To","p":["To check if a field value is not equal to a value, you can use the notEq function.","Similarly, you can use the notEq function with KProperty.","More details on notEq function can be found here."]},{"l":"Greater Than","p":["To check if a field value is greater than a value, you can use the gt function.","Similarly, you can use the gt function with KProperty.","More details on gt function can be found here."]},{"l":"Greater Than or Equal To","p":["To check if a field value is greater than or equal to a value, you can use the gte function.","Similarly, you can use the gte function with KProperty.","More details on gte function can be found here."]},{"l":"Less Than","p":["To check if a field value is less than a value, you can use the lt function.","Similarly, you can use the lt function with KProperty.","More details on lt function can be found here."]},{"l":"Less Than or Equal To","p":["To check if a field value is less than or equal to a value, you can use the lte function.","Similarly, you can use the lte function with KProperty.","More details on lte function can be found here."]},{"l":"Within","p":["To check if a field value is in a list of values, you can use the within function.","Similarly, you can use the within function with KProperty.","You can also use it with range.","More details on within function can be found here."]},{"l":"Not Within","p":["To check if a field value is not in a list of values, you can use the notWithin function.","Similarly, you can use the notWithin function with KProperty.","You can also use it with range.","More details on notWithin function can be found here."]},{"l":"Between","p":["To check if a field value is between two values, you can use the between function. More details on between function can be found here."]},{"l":"Logical Filters","p":["Logical operators are used to combine two or more expressions. More details on logical operators can be found here."]},{"l":"And","p":["To combine two or more expressions with AND operator, you can use the and function.","Similarly, you can use the and function with KProperty.","More details on and function can be found here."]},{"l":"Or","p":["To combine two or more expressions with OR operator, you can use the or function.","Similarly, you can use the or function with KProperty.","More details on or function can be found here."]},{"l":"Array Filters","p":["Array filters are used to match documents based on the values in an array field. More details on array filters can be found here."]},{"l":"Element Match","p":["To check if an array field contains at least one element that matches the specified filter, you can use the elemMatch function.","Similarly, you can use the elemMatch function with KProperty.","More details on elemMatch function can be found here."]},{"l":"Evaluation Filters","p":["Evaluation filters are used to match documents based on evaluating the value of any field in a document. More details on evaluation filters can be found here."]},{"l":"Regex","p":["To check if a field value matches a regular expression, you can use the regex function.","Similarly, you can use the regex function with KProperty.","More details on regex function can be found here."]},{"l":"Text","p":["The text filter is used to match documents which contain a specified full-text search expression.","Similarly, you can use the text function with KProperty.","More details on text function can be found here."]},{"l":"Spatial Filters","p":["Spatial filters are used to match documents based on their geometric shape. More details on spatial filters can be found here."]},{"l":"Near","p":["To check if a field value is near to a point, you can use the near function.","Similarly, you can use the near function with KProperty.","More details on near function can be found here."]},{"i":"within-1","l":"Within","p":["To check if a field value is within a specified shape, you can use the within function.","Similarly, you can use the within function with KProperty.","More details on within function can be found here."]},{"l":"Intersects","p":["The intersects filter is used to match documents where the value of the spatial field intersects the specified shape.","Similarly, you can use the intersects function with KProperty.","More details on intersects function can be found here."]}],[{"l":"Transaction","p":["Nitrite supports transactional operations on its collections and repositories. A transaction can be committed or rolled back. Once a transaction is committed, all the changes are persisted to the disk. If a transaction is rolled back, all the changes are discarded.","More information about Nitrite transactions can be found here."]},{"l":"Kotlin API for Transaction","p":["Potassium Nitrite provides a set of builder functions for Session and Transaction to make transaction usage more like natural to Kotlin."]},{"l":"Session","p":["A session represents a transactional context for a Nitrite database. Session is used to create a new transaction. More details on session can be found here."]},{"l":"Kotlin API for Session","p":["To create a new session, you can use the session() extension function on Nitrite.","Session will be automatically closed once the block is executed."]},{"l":"Transaction","p":["A transaction is a single logical unit of work which accesses and possibly modifies the contents of a database. Transactions access data using read and write operations. More details on transaction can be found here."]},{"i":"kotlin-api-for-transaction-1","l":"Kotlin API for Transaction","p":["To start a transaction, you can use the tx() extension function on Session.","Transaction will be automatically closed once the block is executed."]}],[{"l":"Potassium Nitrite Module","p":["Nitrite is a modular database engine, so is Potassium Nitrite. All Nitrite modules are compatible with Potassium Nitrite as well. More details about Nitrite modules can be found here.","Potassium Nitrite provides a single module KNO2Module to load all plugins it provides. You can load the module while opening the database.","This module loads the following plugins:","KNO2JacksonMapper- A Jackson based mapper for Potassium Nitrite.","SpatialIndexer- A spatial index plugin for Nitrite.","Visit the respective pages to know more about the plugins."]}],[{"i":"#","p":["This guide will help you get started with Nitrite database. It will show you how to create a database, create a collection, insert documents, and query documents in Flutter."]},{"l":"Getting Started in Flutter","p":["To get started with Nitrite database, you need to add the dependency to your pubspec.yaml file."]},{"l":"Add dependency","p":["Add Nitrite dependency to your project:"]}],[{"l":"Database"}],[{"l":"Document"}],[{"l":"Nitrite Collection"}],[{"l":"Object Repository"}],[{"l":"Entity"}],[{"l":"CRUD Operations"}],[{"l":"Indexing"}],[{"l":"Query"}],[{"l":"Transaction"}],[{"l":"Migration"}],[{"l":"Module System"}],[{"l":"Hive Modules"}],[{"l":"Spatial Module"}],[{"i":"importexport","l":"Import/Export"}],[{"l":"Encryption"}],[{"l":"Java Examples"}],[{"l":"Kotlin Examples"}],[{"l":"Flutter Examples"}],[{"l":"Showcase"},{"l":"Applications using Nitrite Database","p":["Submit your application below to showcase it here."]},{"l":"Showcase Your Application","p":["If you are using Nitrite Database in your application, please fill up the form below. We will showcase your application in this page."]}],[{"l":"FAQ"}]];